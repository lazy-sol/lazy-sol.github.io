{
  "language": "Solidity",
  "sources": {
    "@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for ERC1967 proxies, as well as for EIP-1167 minimal proxies\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControl is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the RBAC implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges, can be zero\n\t * @param _features initial features mask of the contract, can be zero\n\t */\n\tfunction _postConstruct(address _owner, uint256 _features) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t\t// update initial features bitmask\n\t\t__setRole(address(this), _features, _features);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./InitializableAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the RBAC, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is InitializableAccessControl, UUPSUpgradeable {\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721\n *\n * @notice Defines mint capabilities for ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns(bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `safeMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Burnable ERC721\n *\n * @notice Defines burn capabilities for ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n\n/**\n * @title With Base URI\n *\n * @notice A marker interface for the contracts having the baseURI() function\n *      or public string variable named baseURI\n *\n * @author Basil Gorin\n */\ninterface WithBaseURI {\n\t/**\n\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t */\n\tfunction baseURI() external view returns(string memory);\n}\n"
    },
    "contracts/lib/AddressUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Address Utils\n *\n * @dev Utility library of inline functions on addresses\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/gnosis/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\n */\nlibrary AddressUtils {\n\n\t/**\n\t * @notice Checks if the target address is a contract\n\t *\n\t * @dev It is unsafe to assume that an address for which this function returns\n\t *      false is an externally-owned account (EOA) and not a contract.\n\t *\n\t * @dev Among others, `isContract` will return false for the following\n\t *      types of addresses:\n\t *        - an externally-owned account\n\t *        - a contract in construction\n\t *        - an address where a contract will be created\n\t *        - an address where a contract lived, but was destroyed\n\t *\n\t * @param addr address to check\n\t * @return whether the target address is a contract\n\t */\n\tfunction isContract(address addr) internal view returns (bool) {\n\t\t// a variable to load `extcodesize` to\n\t\tuint256 size = 0;\n\n\t\t// XXX Currently there is no better way to check if there is a contract in an address\n\t\t// than to check the size of the code at that address.\n\t\t// See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\n\t\t// TODO: Check this again before the Serenity release, because all addresses will be contracts.\n\t\t// solium-disable-next-line security/no-inline-assembly\n\t\tassembly {\n\t\t\t// retrieve the size of the code at address `addr`\n\t\t\tsize := extcodesize(addr)\n\t\t}\n\n\t\t// positive size indicates a smart contract address\n\t\treturn size > 0;\n\t}\n}\n"
    },
    "contracts/lib/ArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Array Utils\n *\n * @notice Solidity doesn't always work with arrays in an optimal way.\n *      This library collects functions helping to optimize gas usage\n *      when working with arrays in Solidity.\n *\n * @dev One of the most important use cases for arrays is \"tight\" arrays -\n *      arrays which store values significantly less than 256-bits numbers\n *\n * @author Basil Gorin\n */\nlibrary ArrayUtils {\n\t/**\n\t * @dev Pushes `n` 32-bits values sequentially into storage allocated array `data`\n\t *      starting from the 32-bits value `v0`\n\t *\n\t * @dev Optimizations comparing to non-assembly implementation:\n\t *      - reads+writes to array size slot only once (instead of `n` times)\n\t *      - reads from the array data slots only once (instead of `7n/8` times)\n\t *      - writes into array data slots `n/8` times (instead of `n` times)\n\t *\n\t * @dev Maximum gas saving estimate: ~3n sstore, or 15,000 * n\n\t *\n\t * @param data storage array pointer to an array of 32-bits elements\n\t * @param v0 first number to push into the array\n\t * @param n number of values to push, pushes [v0, ..., v0 + n - 1]\n\t */\n\tfunction push32(uint32[] storage data, uint32 v0, uint32 n) internal {\n\t\t// we're going to write 32-bits values into 256-bits storage slots of the array\n\t\t// each 256-slot can store up to 8 32-bits sub-blocks, it can also be partially empty\n\t\tassembly {\n\t\t\t// for dynamic arrays their slot (array.slot) contains the array length\n\t\t\t// array data is stored separately in consequent storage slots starting\n\t\t\t// from the slot with the address keccak256(array.slot)\n\n\t\t\t// read the array length into `len` and increase it by `n`\n\t\t\tlet len := sload(data.slot)\n\t\t\tsstore(data.slot, add(len, n))\n\n\t\t\t// find where to write elements and store this location into `loc`\n\t\t\t// load array storage slot number into memory onto position 0,\n\t\t\t// calculate the keccak256 of the slot number (first 32 bytes at position 0)\n\t\t\t// - this will point to the beginning of the array,\n\t\t\t// so we add array length divided by 8 to point to the last array slot\n\t\t\tmstore(0, data.slot)\n\t\t\tlet loc := add(keccak256(0, 32), div(len, 8))\n\n\t\t\t// if we start writing data into already partially occupied slot (`len % 8 != 0`)\n\t\t\t// we need to modify the contents of that slot: read it and rewrite it\n\t\t\tlet offset := mod(len, 8)\n\t\t\tif not(iszero(offset)) {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := sub(8, offset)\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// load the contents of the first slot (partially occupied)\n\t\t\t\tlet v256 := sload(loc)\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `(j + offset) * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + j) << (j + offset) * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(add(j, offset), 32), add(v0, j)))\n\t\t\t\t}\n\t\t\t\t// write first slot back, it can be still partially occupied, it can also be full\n\t\t\t\tsstore(loc, v256)\n\t\t\t\t// update `loc`: move to the next slot\n\t\t\t\tloc := add(loc, 1)\n\t\t\t\t// update `v0`: increment by number of values pushed\n\t\t\t\tv0 := add(v0, left)\n\t\t\t\t// update `n`: decrement by number of values pushed\n\t\t\t\tn := sub(n, left)\n\t\t\t}\n\n\t\t\t// rest of the slots (if any) are empty and will be only written to\n\t\t\t// write the array in 256-bits (8x32) slots\n\t\t\t// `i` iterates [0, n) with the 256-bits step, which is 8 taken `n` is 32-bits long\n\t\t\tfor { let i := 0 } lt(i, n) { i := add(i, 8) } {\n\t\t\t\t// how many 32-bits sub-blocks left in the slot\n\t\t\t\tlet left := 8\n\t\t\t\t// update the `left` value not to exceed `n`\n\t\t\t\tif gt(left, n) { left := n }\n\t\t\t\t// init the 256-bits slot value\n\t\t\t\tlet v256 := 0\n\t\t\t\t// write the slot in 32-bits sub-blocks\n\t\t\t\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\n\t\t\t\t\t// write sub-block `j` at offset: `j * 32` bits, length: 32-bits\n\t\t\t\t\t// v256 |= (v0 + i + j) << j * 32\n\t\t\t\t\tv256 := or(v256, shl(mul(j, 32), add(v0, add(i, j))))\n\t\t\t\t}\n\t\t\t\t// write slot `i / 8`\n\t\t\t\tsstore(add(loc, div(i, 8)), v256)\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n}\n"
    },
    "contracts/lib/StringUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title String Utils Library\n *\n * @dev Library for working with strings, primarily converting\n *      between strings and integer types\n *\n * @author Basil Gorin\n */\nlibrary StringUtils {\n\t/**\n\t * @dev Converts a string to unsigned integer using the specified `base`\n\t * @dev Throws on invalid input\n\t *      (wrong characters for a given `base`)\n\t * @dev Throws if given `base` is not supported\n\t * @param a string to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return i a number representing given string\n\t */\n\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// convert string into bytes for convenient iteration\n\t\tbytes memory buf = bytes(a);\n\n\t\t// iterate over the string (bytes buffer)\n\t\tfor(uint256 p = 0; p < buf.length; p++) {\n\t\t\t// extract the digit\n\t\t\tuint8 digit = uint8(buf[p]) - 0x30;\n\n\t\t\t// if digit is greater then 10 - mind the gap\n\t\t\t// see `itoa` function for more details\n\t\t\tif(digit > 10) {\n\t\t\t\t// remove the gap\n\t\t\t\tdigit -= 7;\n\t\t\t}\n\n\t\t\t// check if digit meets the base\n\t\t\trequire(digit < base);\n\n\t\t\t// move to the next digit slot\n\t\t\ti *= base;\n\n\t\t\t// add digit to the result\n\t\t\ti += digit;\n\t\t}\n\n\t\t// return the result\n\t\treturn i;\n\t}\n\n\t/**\n\t * @dev Converts a integer to a string using the specified `base`\n\t * @dev Throws if given `base` is not supported\n\t * @param i integer to convert\n\t * @param base number base, one of 2, 8, 10, 16\n\t * @return a a string representing given integer\n\t */\n\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\n\t\t// check if the base is valid\n\t\trequire(base == 2 || base == 8 || base == 10 || base == 16);\n\n\t\t// for zero input the result is \"0\" string for any base\n\t\tif(i == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\n\t\t// bytes buffer to put ASCII characters into\n\t\tbytes memory buf = new bytes(256);\n\n\t\t// position within a buffer to be used in cycle\n\t\tuint256 p = 0;\n\n\t\t// extract digits one by one in a cycle\n\t\twhile(i > 0) {\n\t\t\t// extract current digit\n\t\t\tuint8 digit = uint8(i % base);\n\n\t\t\t// convert it to an ASCII code\n\t\t\t// 0x20 is \" \"\n\t\t\t// 0x30-0x39 is \"0\"-\"9\"\n\t\t\t// 0x41-0x5A is \"A\"-\"Z\"\n\t\t\t// 0x61-0x7A is \"a\"-\"z\" (\"A\"-\"Z\" XOR \" \")\n\t\t\tuint8 ascii = digit + 0x30;\n\n\t\t\t// if digit is greater then 10,\n\t\t\t// fix the 0x3A-0x40 gap of punctuation marks\n\t\t\t// (7 characters in ASCII table)\n\t\t\tif(digit >= 10) {\n\t\t\t\t// jump through the gap\n\t\t\t\tascii += 7;\n\t\t\t}\n\n\t\t\t// write character into the buffer\n\t\t\tbuf[p++] = bytes1(ascii);\n\n\t\t\t// move to the next digit\n\t\t\ti /= base;\n\t\t}\n\n\t\t// `p` contains real length of the buffer now,\n\t\t// allocate the resulting buffer of that size\n\t\tbytes memory result = new bytes(p);\n\n\t\t// copy the buffer in the reversed order\n\t\tfor(p = 0; p < result.length; p++) {\n\t\t\t// copy from the beginning of the original buffer\n\t\t\t// to the end of resulting smaller buffer\n\t\t\tresult[result.length - p - 1] = buf[p];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(result);\n\t}\n\n\t/**\n\t * @dev Concatenates two strings `s1` and `s2`, for example, if\n\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\n\t * @param s1 first string\n\t * @param s2 second string\n\t * @return s concatenation result s1 + s2\n\t */\n\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\n\t\t// an old way of string concatenation (Solidity 0.4) is commented out\n/*\n\t\t// convert s1 into buffer 1\n\t\tbytes memory buf1 = bytes(s1);\n\t\t// convert s2 into buffer 2\n\t\tbytes memory buf2 = bytes(s2);\n\t\t// create a buffer for concatenation result\n\t\tbytes memory buf = new bytes(buf1.length + buf2.length);\n\n\t\t// copy buffer 1 into buffer\n\t\tfor(uint256 i = 0; i < buf1.length; i++) {\n\t\t\tbuf[i] = buf1[i];\n\t\t}\n\n\t\t// copy buffer 2 into buffer\n\t\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\n\t\t\tbuf[j] = buf2[j - buf1.length];\n\t\t}\n\n\t\t// construct string and return\n\t\treturn string(buf);\n*/\n\n\t\t// simply use built in function\n\t\treturn string(abi.encodePacked(s1, s2));\n\t}\n}\n"
    },
    "contracts/mocks/ArrayBlockMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/ArrayUtils.sol\";\n\n/**\n * @dev Helper contract to measure sequential array writing gas savings\n * @dev Supports seq_rnd_gas.js tess and ArrayUtils library\n */\ncontract ArrayBlockMock {\n\tusing ArrayUtils for uint32[];\n\tuint32[] public array321;\n\tuint32[] public array322;\n\tuint256[] public array2561;\n\tuint256[] public array2562;\n\n\tfunction writeSequential(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t}\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writeRandomized(uint32 m, uint32 n) public {\n\t\tfor(uint32 i = 0; i < n; i++) {\n\t\t\tarray321.push(i + m);\n\t\t\tarray322.push(i + m);\n\t\t}\n\t}\n\n\tfunction writePacked(uint32 m, uint32 n) public {\n\t\tfor(uint256 i = 0; i < n; i += 8) {\n\t\t\tuint256 e = 0;\n\t\t\tfor(uint256 j = 0; j < 8; j++) {\n\t\t\t\te |= (i + j + m) << j * 32;\n\t\t\t}\n\t\t\tarray2561.push(e);\n\t\t\tarray2562.push(e);\n\t\t}\n\t}\n\n\tfunction writeWithAssembly(uint32 m, uint32 n) public {\n\t\tarray321.push32(m, n);\n\t\tarray322.push32(m, n);\n\t}\n\n\tfunction getArray321() public view returns(uint32[] memory) {\n\t\treturn array321;\n\t}\n\n\tfunction getArray322() public view returns(uint32[] memory) {\n\t\treturn array322;\n\t}\n\n\tfunction getArray2561() public view returns(uint256[] memory) {\n\t\treturn array2561;\n\t}\n\n\tfunction getArray2562() public view returns(uint256[] memory) {\n\t\treturn array2562;\n\t}\n\n}\n"
    },
    "contracts/mocks/LockableTinyERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/TinyERC721.sol\";\n\ncontract LockableTinyERC721Mock is TinyERC721 {\n\t/// @dev Used to override isTransferable behaviour\n\tmapping(uint256 => bool) private transferable;\n\n\tconstructor(address _contractOwner, string memory _name, string memory _symbol, uint256 _initialFeatures)\n\tTinyERC721(_contractOwner, _name, _symbol, _initialFeatures) {}\n\n\t/// @dev Used to override isTransferable behaviour\n\tfunction setTransferable(uint256 _tokenId, bool _value) public {\n\t\ttransferable[_tokenId] = _value;\n\t}\n\n\t/**\n\t * @inheritdoc TinyERC721\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view override returns(bool) {\n\t\treturn transferable[_tokenId];\n\t}\n}\n"
    },
    "contracts/mocks/ZeppelinERC721ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\n\ncontract ZeppelinERC721ReceiverMock is ERC721TokenReceiver {\n\tenum Error {\n\t\tNone,\n\t\tRevertWithMessage,\n\t\tRevertWithoutMessage,\n\t\tPanic\n\t}\n\n\tbytes4 private immutable _retval;\n\tError private immutable _error;\n\n\tevent Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n\tconstructor(bytes4 retval, Error error) {\n\t\t_retval = retval;\n\t\t_error = error;\n\t}\n\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public override returns (bytes4) {\n\t\tif (_error == Error.RevertWithMessage) {\n\t\t\trevert(\"ERC721ReceiverMock: reverting\");\n\t\t} else if (_error == Error.RevertWithoutMessage) {\n\t\t\trevert();\n\t\t} else if (_error == Error.Panic) {\n\t\t\tuint256 a = uint256(0) / uint256(0);\n\t\t\ta;\n\t\t}\n\t\temit Received(operator, from, tokenId, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/protocol/GenericFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/**\n * @title Generic Factory, a.k.a Generic Smart Contract Deployer\n *\n * @notice A helper stand-alone contract allowing to \"clone\" anything\n *\n * @dev The deployment is done via EIP-1167 Minimal Proxy Contract\n *      See https://eips.ethereum.org/EIPS/eip-1167\n *\n * @author Basil Gorin\n */\ncontract GenericFactoryV1 is UpgradeableAccessControl {\n\t/**\n\t * @dev Fired in clone()\n\t *\n\t * @param proxyAddress deployed EIP-1167 clone (proxy) address,\n\t *      this is the main `clone()` function output\n\t * @param implAddress impl address used for cloning\n\t * @param data optional data bytes passed to the proxy for initialization;\n\t *      can be empty, in which case this means proxy wasn't initialized\n\t * @param returnData when data field is used, contains the response from low-level\n\t *      proxy initialization call; can be empty\n\t */\n\tevent ProxyDeployed(\n\t\taddress proxyAddress,\n\t\taddress indexed implAddress,\n\t\tbytes data,\n\t\tbytes returnData\n\t);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t */\n\tfunction postConstruct() public initializer {\n\t\t// initialize the RBAC module\n\t\t_postConstruct(msg.sender, 0);\n\t}\n\n\t/**\n\t * @notice Clones the specified contract and optionally initializes it immediately\n\t *\n\t * @dev Technically this deploys a tiny EIP 1167 proxy pointing to the impl address specified\n\t *      and optionally initializes it immediately, making the deployment safe and ready for use\n\t *\n\t * @dev Throws on proxy initialization failure\n\t *\n\t * @param _implAddress contract implementation address to clone\n\t * @param _data optional bytes data to execute the low-level call on cloned instance for initialization\n\t */\n\tfunction clone(address _implAddress, bytes calldata _data) public returns(address proxyAddress, bytes memory returnData) {\n\t\t// \"clone\" the impl (deploy a proxy)\n\t\tproxyAddress = Clones.clone(_implAddress);\n\n\t\t// if initialization data is specified\n\t\tif(_data.length > 0) {\n\t\t\t// allocate the variable to store low-level call status\n\t\t\tbool success;\n\t\t\t// initialize the proxy by invoking the low-level call\n\t\t\t(success, returnData) = proxyAddress.call(_data);\n\t\t\t// we require the call to be successful\n\t\t\trequire(success, \"proxy initialization failed\");\n\t\t}\n\n\t\t// emit an event\n\t\temit ProxyDeployed(proxyAddress, _implAddress, _data, returnData);\n\n\t\t// explicitly return the results\n\t\treturn (proxyAddress, returnData);\n\t}\n}\n"
    },
    "contracts/token/TinyERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../lib/AddressUtils.sol\";\nimport \"../lib/ArrayUtils.sol\";\nimport \"../lib/StringUtils.sol\";\nimport \"../lib/ECDSA.sol\";\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControl.sol\";\n\n/**\n * @title Tiny ERC721, a.k.a 32bit NFT\n *\n * @notice Tiny ERC721 defines an NFT with an integer (up to 32 bits) ID space.\n *\n * @notice Rationale\n *      Problem: ERC721 enumeration support requires some additional writes to the storage:\n *      - when transferring a token in order to update the NFT collections of\n *        the previous and next owners,\n *      - when minting/burning a token in order to update global NFT collection\n *\n *      Solution: Reducing NFT ID space to 32 bits allows\n *      - to eliminate the need to have and to write to two additional storage mappings\n *        (also achievable with the 48 bits ID space)\n *      - when batch minting, an optimization of writing 8 tokens at once into\n *        global/local collections applies\n *\n * @notice This smart contract can be used as is, but also can be inherited and used as a template.\n *\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\n *      see https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\n *\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to OZ impl:\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\n *         still the URI will be deleted once token is burnt\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\n *         base URI is used to construct the token URI only if the latter was not explicitly set\n *\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\n *\n * @dev EIP712 Domain:\n *      name: TinyERC721v1\n *      version: not in use, omitted (name already contains version)\n *      chainId: EIP-155 chain id\n *      verifyingContract: deployed contract address\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\n *\n * @dev Permit type:\n *      owner: address\n *      operator: address\n *      tokenId: uint256\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev Permit typeHash:\n *        keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n *\n * @dev PermitForAll type:\n *      owner: address\n *      operator: address\n *      approved: bool\n *      nonce: uint256\n *      deadline: uint256\n *\n * @dev PermitForAll typeHash:\n *        keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n *\n * @dev See https://eips.ethereum.org/EIPS/eip-712\n * @dev See usage examples in tests: erc721_permits.js\n *\n * @author Basil Gorin\n */\ncontract TinyERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, BurnableERC721, InitializableAccessControl {\n\t// enable push32 optimization for uint32[]\n\tusing ArrayUtils for uint32[];\n\n\t/**\n\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override name;\n\n\t/**\n\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tstring public override symbol;\n\n\t/**\n\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\n\t *      to be more compatible with ERC-20\n\t *\n\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\n\t *      and therefore non-divisible\n\t */\n\tuint8 public constant decimals = 0;\n\n\t/**\n\t * @notice Ownership information for all the tokens in existence\n\t *\n\t * @dev Maps `Token ID => Token ID Global Index | Token ID Local Index | Token Owner Address`, where\n\t *      - Token ID Global Index denotes Token ID index in the array of all the tokens,\n\t *      - Token ID Local Index denotes Token ID index in the array of all the tokens owned by the owner,\n\t *      - Token ID indexes are 32 bits long,\n\t *      - `|` denotes bitwise concatenation of the values\n\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\n\t */\n\tmapping(uint256 => uint256) internal tokens;\n\n\t/**\n\t * @notice Enumerated collections of the tokens owned by particular owners\n\t *\n\t * @dev We call these collections \"Local\" token collections\n\t *\n\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\n\t *\n\t * @dev Token owner balance is the length of their token collection:\n\t *      `balanceOf(owner) = collections[owner].length`\n\t */\n\tmapping(address => uint32[]) internal collections;\n\n\t/**\n\t * @notice An array of all the tokens in existence\n\t *\n\t * @dev We call this collection \"Global\" token collection\n\t *\n\t * @dev Array with all Token IDs, used for enumeration\n\t *\n\t * @dev Total token supply `tokenSupply` is the length of this collection:\n\t *      `totalSupply() = allTokens.length`\n\t */\n\tuint32[] internal allTokens;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer their tokens\n\t *\n\t * @dev `Maps Token ID => Approved Address`, where\n\t *      Approved Address is an address allowed transfer ownership for the token\n\t *      defined by Token ID\n\t */\n\tmapping(uint256 => address) internal approvals;\n\n\t/**\n\t * @notice Addresses approved by token owners to transfer all their tokens\n\t *\n\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\n\t *      - Token Owner Address is any address which may own tokens or not,\n\t *      - Operator Address is any other address which may own tokens or not,\n\t *      - Approval State is a flag indicating if Operator Address is allowed to\n\t *        transfer tokens owned by Token Owner Address o their behalf\n\t */\n\tmapping(address => mapping(address => bool)) internal approvedOperators;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\n\t *      `permit` and `permitForAll` functions\n\t *\n\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\n\t *      of the EIP-712 transactions is not possible\n\t *\n\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\n\t *\n\t * @dev Maps token owner address => token owner nonce\n\t */\n\tmapping(address => uint256) public permitNonces;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public override baseURI = \"\";\n\n\t/**\n\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\n\t *      is called; if mapping doesn't exist for token, the URI is constructed\n\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\n\t */\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t/**\n\t * @dev 32 bit token ID space is optimal for batch minting in batches of size 8\n\t *      8 * 32 = 256 - single storage slot in global/local collection(s)\n\t */\n\tuint8 public constant BATCH_SIZE_MULTIPLIER = 8;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\n\t * @dev Feature FEATURE_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\n\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\n\t *      `permitForAll()` function to succeed\n\t */\n\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0400;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"TinyERC721v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract's domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"TinyERC721v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\n\n\t/**\n\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _tokenId token ID which URI was updated\n\t * @param _oldVal old _baseURI value\n\t * @param _newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\n\n\t/**\n\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\n\t *\n\t * @param _contractOwner smart contract owner (has minting/burning and all other permissions)\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _initialFeatures RBAC features enabled initially\n\t */\n\tconstructor(address _contractOwner, string memory _name, string memory _symbol, uint256 _initialFeatures) {\n\t\t// delegate to the same `postConstruct` function which would be used\n\t\t// by all the proxies to be deployed and to be pointing to this impl\n\t\tpostConstruct(_contractOwner, _name, _symbol, _initialFeatures);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _contractOwner smart contract owner (has minting/burning and all other permissions)\n\t * @param _name name of the token to be accessible as `name()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _symbol token symbol to be accessible as `symbol()`,\n\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\n\t * @param _initialFeatures RBAC features enabled initially\n\t */\n\tfunction postConstruct(\n\t\taddress _contractOwner,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\tuint256 _initialFeatures\n\t) public initializer {\n\t\t// verify name and symbol are set\n\t\trequire(bytes(_name).length > 0, \"token name is not set\");\n\t\trequire(bytes(_symbol).length > 0, \"token symbol is not set\");\n\n\t\t// assign token name and symbol\n\t\tname = _name;\n\t\tsymbol = _symbol;\n\n\t\t// if initial contract owner is specified\n\t\tif(_contractOwner != address(0) || _initialFeatures != 0) {\n\t\t\t// initialize the RBAC module\n\t\t\t_postConstruct(_contractOwner, _initialFeatures);\n\t\t}\n\t}\n\n\n\t/**\n\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\n\t *      The default behaviour is to always allow transfer if token exists\n\t *\n\t * @dev Implementations may modify the default behaviour based on token metadata\n\t *      if required\n\t *\n\t * @param _tokenId ID of the token to check if it's transferable\n\t * @return true if token is transferable, false otherwise\n\t */\n\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\n\t\t// validate token existence\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// generic implementation returns true if token exists\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @inheritdoc MintableERC721\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public override view returns(bool) {\n\t\t// read ownership information and return a check if it's not zero (set)\n\t\treturn tokens[_tokenId] != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// construct the interface support from required and optional ERC721 interfaces\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t\t|| interfaceId == type(ERC721).interfaceId\n\t\t\t|| interfaceId == type(ERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ERC721Enumerable).interfaceId\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t// ===== Start: ERC721 Metadata =====\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory _baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = _baseURI;\n\t}\n\n\t/**\n\t * @dev Returns token URI if it was previously set with `setTokenURI`,\n\t *      otherwise constructs it as base URI + token ID\n\t *\n\t * @inheritdoc ERC721Metadata\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\n\t\t// verify token exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the token URI for the token specified\n\t\tstring memory _tokenURI = _tokenURIs[_tokenId];\n\n\t\t// if token URI is set\n\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t// just return it\n\t\t\treturn _tokenURI;\n\t\t}\n\n\t\t// if base URI is not set\n\t\tif(bytes(baseURI).length == 0) {\n\t\t\t// return an empty string\n\t\t\treturn \"\";\n\t\t}\n\n\t\t// otherwise concatenate base URI + token ID\n\t\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\n\n\t\t// and update token URI\n\t\t_tokenURIs[_tokenId] = _tokenURI;\n\t}\n\n\t// ===== End: ERC721 Metadata =====\n\n\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256) {\n\t\t// check `_owner` address is set\n\t\trequire(_owner != address(0), \"zero address\");\n\n\t\t// derive owner balance for the their owned tokens collection\n\t\t// as the length of that collection\n\t\treturn collections[_owner].length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\n\t\t// derive ownership information of the token from the ownership mapping\n\t\t// by extracting lower 160 bits of the mapping value as an address\n\t\taddress owner = address(uint160(tokens[_tokenId]));\n\n\t\t// verify owner/token exists\n\t\trequire(owner != address(0), \"token doesn't exist\");\n\n\t\t// return owner address\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction totalSupply() public view override returns (uint256) {\n\t\t// derive total supply value from the array of all existing tokens\n\t\t// as the length of this array\n\t\treturn allTokens.length;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < totalSupply(), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn allTokens[_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Enumerable\n\t */\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\n\t\t// index out of bounds check\n\t\trequire(_index < balanceOf(_owner), \"index out of bounds\");\n\n\t\t// find the token ID requested and return\n\t\treturn collections[_owner][_index];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\n\t\t// verify token specified exists\n\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t// read the approval value and return\n\t\treturn approvals[_tokenId];\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\n\t\t// read the approval state value and return\n\t\treturn approvedOperators[_owner][_operator];\n\t}\n\n\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\n\n\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate call to unsafe transfer on behalf `transferFrom()`\n\t\ttransferFrom(_from, _to, _tokenId);\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// delegate call to overloaded `safeTransferFrom()`, set data to \"\"\n\t\tsafeTransferFrom(_from, _to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// validate destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// validate token ownership, which also\n\t\t// validates token existence under the hood\n\t\trequire(_from == ownerOf(_tokenId), \"access denied\");\n\n\t\t// verify operator (transaction sender) is either token owner,\n\t\t// or is approved by the token owner to transfer this particular token,\n\t\t// or is approved by the token owner to transfer any of his tokens\n\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\n\t\t// transfer is not allowed for a locked token\n\t\trequire(isTransferable(_tokenId), \"locked token\");\n\n\t\t// if required, move token ownership,\n\t\t// update old and new owner's token collections accordingly:\n\t\tif(_from != _to) {\n\t\t\t// remove token from old owner's collection (also clears approval)\n\t\t\t__removeLocal(_tokenId);\n\t\t\t// add token to the new owner's collection\n\t\t\t__addLocal(_tokenId, _to);\n\t\t}\n\t\t// even if no real changes are required, approval needs to be erased\n\t\telse {\n\t\t\t// clear token approval (also emits an Approval event)\n\t\t\t__clearApproval(_from, _tokenId);\n\t\t}\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction approve(address _approved, uint256 _tokenId) public override {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _approved, _tokenId);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\n\t *\n\t * @dev Approves address called `_operator` to transfer token `_tokenId`\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev Zero `_operator` address indicates there is no approved address,\n\t *      and effectively removes an approval for the token specified\n\t *\n\t * @dev `_owner` must own token `_tokenId` to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`),\n\t *      or if `_tokenId` doesn't exist\n\t *\n\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\n\t * @param _operator an address approved by the token owner\n\t *      to spend token `_tokenId` on its behalf\n\t * @param _tokenId token ID operator `_approved` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\n\t\t// get token owner address\n\t\taddress owner = ownerOf(_tokenId);\n\n\t\t// approving owner address itself doesn't make sense and is not allowed\n\t\trequire(_operator != owner, \"self approval\");\n\n\t\t// only token owner or/and approved operator can set the approval\n\t\trequire(_owner == owner || isApprovedForAll(owner, _owner), \"access denied\");\n\n\t\t// update the approval\n\t\tapprovals[_tokenId] = _operator;\n\n\t\t// emit an event\n\t\temit Approval(owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction setApprovalForAll(address _operator, bool _approved) public override {\n\t\t// make an internal approve - delegate to `__approveForAll`\n\t\t__approveForAll(msg.sender, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\n\t *\n\t * @dev Approves address called `_operator` to transfer any tokens\n\t *      on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_operator` is a self address (`_owner`)\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t */\n\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\n\t\t// approving tx sender address itself doesn't make sense and is not allowed\n\t\trequire(_operator != _owner, \"self approval\");\n\n\t\t// update the approval\n\t\tapprovedOperators[_owner][_operator] = _approved;\n\n\t\t// emit an event\n\t\temit ApprovalForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Clears approval for a given token owned by a given owner,\n\t *      emits an Approval event\n\t *\n\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\n\t *      assuming the check is done by the caller\n\t *      - token existence\n\t *      - token ownership\n\t *\n\t * @param _owner token owner to be logged into Approved event as is\n\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\n\t */\n\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\n\t\t// clear token approval\n\t\tdelete approvals[_tokenId];\n\t\t// emit an ERC721 Approval event:\n\t\t// \"When a Transfer event emits, this also indicates that the approved\n\t\t// address for that NFT (if any) is reset to none.\"\n\t\temit Approval(_owner, address(0), _tokenId);\n\t}\n\n\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\n\n\t// ===== Start: Meta-transactions Support =====\n\n\t/**\n\t * @notice Change or reaffirm the approved address for an NFT on behalf\n\t *\n\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `Approval` event in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the token to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator new approved NFT controller\n\t * @param _tokenId token ID to approve\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_PERMITS), \"permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _operator, _tokenId);\n\t}\n\n\t/**\n\t * @notice Enable or disable approval for a third party (\"operator\") to manage\n\t *      all of owner's assets - on behalf\n\t *\n\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\n\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\n\t *\n\t * @dev Requires:\n\t *     - `_operator` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _operator an address to add to the set of authorized operators, i.e.\n\t *      an address approved by the token owner to spend tokens on its behalf\n\t * @param _approved true if the operator is approved, false to revoke approval\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \"operator permits are disabled\");\n\n\t\t// derive signer of the EIP712 PermitForAll message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approveForAll(_owner, _operator, _approved);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\t// this check already happened inside `ECDSA.recover`\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t// ===== End: Meta-transactions Support =====\n\n\t// ===== Start: mint/burn support =====\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmint(_to, _tokenId);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\n\n\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMint(_to, _tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\n\t\t// delegate to unsafe mint\n\t\tmintBatch(_to, _tokenId, n);\n\n\t\t// make it safe: execute `onERC721Received`\n\n\t\t// if receiver `_to` is a smart contract\n\t\tif(AddressUtils.isContract(_to)) {\n\t\t\t// onERC721Received: for each token minted\n\t\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t\t// check it supports ERC721 interface - execute onERC721Received()\n\t\t\t\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\n\n\t\t\t\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\n\t\t\t\t// bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))\n\t\t\t\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \"invalid onERC721Received response\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// delegate to `safeMint` with empty data\n\t\tsafeMintBatch(_to, _tokenId, n, \"\");\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\n\t\t// verify token doesn't yet exist\n\t\trequire(!exists(_tokenId), \"already minted\");\n\n\t\t// create token ownership record,\n\t\t// add token to `allTokens` and new owner's collections\n\t\t// add token to both local and global collections (enumerations)\n\t\t__addToken(_tokenId, _to);\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(address(0), _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// verify the inputs\n\n\t\t// verify destination address is set\n\t\trequire(_to != address(0), \"zero address\");\n\t\t// verify n is set properly\n\t\trequire(n > 1, \"n is too small\");\n\t\t// verify the token ID is \"tiny\" (32 bits long at most)\n\t\trequire(uint32(_tokenId) == _tokenId, \"token ID overflow\");\n\t\trequire(uint32(_tokenId + n - 1) == _tokenId + n - 1, \"n-th token ID overflow\");\n\n\t\t// verification: for each token to be minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// verify token doesn't yet exist\n\t\t\trequire(!exists(_tokenId + i), \"already minted\");\n\t\t}\n\n\t\t// create token ownership records,\n\t\t// add tokens to `allTokens` and new owner's collections\n\t\t// add tokens to both local and global collections (enumerations)\n\t\t__addTokens(_to, _tokenId, n);\n\n\t\t// events: for each token minted\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// fire ERC721 transfer event\n\t\t\temit Transfer(address(0), _to, _tokenId + i);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public override {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// remove token ownership record (also clears approval),\n\t\t// remove token from both local and global collections\n\t\t__removeToken(_tokenId);\n\n\t\t// delete token URI mapping\n\t\tdelete _tokenURIs[_tokenId];\n\n\t\t// fire ERC721 transfer event\n\t\temit Transfer(_from, address(0), _tokenId);\n\t}\n\n\t// ===== End: mint/burn support =====\n\n\t// ----- Start: auxiliary internal/private functions -----\n\n\t/**\n\t * @dev Adds token to the new owner's collection (local),\n\t *      used internally to transfer existing tokens, to mint new\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update local index and ownership, do not change global index\n\t\ttokens[_tokenId] = tokens[_tokenId]\n\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t& 0x00000000FFFFFFFF000000000000000000000000000000000000000000000000\n\t\t\t| uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the local collection\n\t\tdestination.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add token to both local and global collections (enumerations),\n\t *      used internally to mint new tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to add\n\t * @param _to new owner address to add token to\n\t */\n\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\n\t\t// get a reference to the collection where token goes to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// update token global and local indexes, ownership\n\t\ttokens[_tokenId] = uint224(allTokens.length) << 192 | uint192(destination.length) << 160 | uint160(_to);\n\n\t\t// push token into the collection\n\t\tdestination.push(uint32(_tokenId));\n\n\t\t// push it into the global `allTokens` collection (enumeration)\n\t\tallTokens.push(uint32(_tokenId));\n\t}\n\n\t/**\n\t * @dev Add tokens to both local and global collections (enumerations),\n\t *      used internally to mint new tokens in batches\n\t *\n\t * @dev Token IDs to be added: [_tokenId, _tokenId + n)\n\t *      n is expected to be greater or equal 2, but this is not checked\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _to new owner address to add token to\n\t * @param _tokenId first token ID to add\n\t * @param n how many tokens to add, sequentially increasing the _tokenId\n\t */\n\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\n\t\t// get a reference to the collection where tokens go to\n\t\tuint32[] storage destination = collections[_to];\n\n\t\t// for each token to be added\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\t// update token global and local indexes, ownership\n\t\t\ttokens[_tokenId + i] = uint224(allTokens.length + i) << 192 | uint192(destination.length + i) << 160 | uint160(_to);\n\t\t}\n\n\t\t// push tokens into the local collection\n\t\tdestination.push32(uint32(_tokenId), uint32(n));\n\t\t// push tokens into the global `allTokens` collection (enumeration)\n\t\tallTokens.push32(uint32(_tokenId), uint32(n));\n\t}\n\n\t/**\n\t * @dev Removes token from owner's local collection,\n\t *      used internally to transfer or burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeLocal(uint256 _tokenId) internal virtual {\n\t\t// read token data, containing global and local indexes, owner address\n\t\tuint256 token = tokens[_tokenId];\n\n\t\t// get a reference to the token's owner collection (local)\n\t\tuint32[] storage source = collections[address(uint160(token))];\n\n\t\t// token index within the collection\n\t\tuint32 i = uint32(token >> 160);\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 sourceId = source[source.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != source.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token local index to point to proper place in the collection\n\t\t\t// preserve global index and ownership info\n\t\t\ttokens[sourceId] = tokens[sourceId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x00000000FFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint192(i) << 160;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tsource[i] = sourceId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tsource.pop();\n\n\t\t// clear token approval (also emits an Approval event)\n\t\t__clearApproval(address(uint160(token)), _tokenId);\n\t}\n\n\t/**\n\t * @dev Removes token from both local and global collections (enumerations),\n\t *      used internally to burn existing tokens\n\t *\n\t * @dev Unsafe: doesn't check for data structures consistency\n\t *      (token existence, token ownership, etc.)\n\t *\n\t * @dev Must be kept private at all times. Inheriting smart contracts\n\t *      may be interested in overriding this function.\n\t *\n\t * @param _tokenId token ID to remove\n\t */\n\tfunction __removeToken(uint256 _tokenId) internal virtual {\n\t\t// remove token from owner's (local) collection first\n\t\t__removeLocal(_tokenId);\n\n\t\t// token index within the global collection\n\t\tuint32 i = uint32(tokens[_tokenId] >> 192);\n\n\t\t// delete the token\n\t\tdelete tokens[_tokenId];\n\n\t\t// get an ID of the last token in the collection\n\t\tuint32 lastId = allTokens[allTokens.length - 1];\n\n\t\t// if the token we're to remove from the collection is not the last one,\n\t\t// we need to move last token in the collection into index `i`\n\t\tif(i != allTokens.length - 1) {\n\t\t\t// we put the last token in the collection to the position released\n\n\t\t\t// update last token global index to point to proper place in the collection\n\t\t\t// preserve local index and ownership info\n\t\t\ttokens[lastId] = tokens[lastId]\n\t\t\t\t//  |unused |global | local | ownership information (address)      |\n\t\t\t\t& 0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t\t\t\t| uint224(i) << 192;\n\n\t\t\t// put it into the position `i` within the collection\n\t\t\tallTokens[i] = lastId;\n\t\t}\n\n\t\t// trim the collection by removing last element\n\t\tallTokens.pop();\n\t}\n\n\t// ----- End: auxiliary internal/private functions -----\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}