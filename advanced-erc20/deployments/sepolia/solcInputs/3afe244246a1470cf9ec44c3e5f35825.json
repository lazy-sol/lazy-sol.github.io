{
  "language": "Solidity",
  "sources": {
    "@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title Initializable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an initializable version of the RBAC, based on Zeppelin implementation,\n *      it can be used for ERC1967 proxies, as well as for EIP-1167 minimal proxies\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *      see https://eips.ethereum.org/EIPS/eip-1167\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#Clones\n *\n * @author Basil Gorin\n */\nabstract contract InitializableAccessControl is Initializable {\n\t/**\n\t * @dev Privileged addresses with defined roles/permissions\n\t * @dev In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t *\n\t * @dev We keep the mapping private to prevent direct writes to it from the inheriting\n\t *      contracts, `getRole()` and `updateRole()` functions should be used instead\n\t */\n\tmapping(address => uint256) private userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param operator address which was granted/revoked permissions\n\t * @param requested permissions requested\n\t * @param assigned permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed operator, uint256 requested, uint256 assigned);\n\n\t/**\n\t * @notice Function modifier making a function defined as public behave as restricted\n\t *      (so that only a pre-configured set of accounts can execute it)\n\t *\n\t * @param role the role transaction executor is required to have;\n\t *      the function throws an \"access denied\" exception if this condition is not met\n\t */\n\tmodifier restrictedTo(uint256 role) {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(role), \"access denied\");\n\n\t\t// execute the rest of the function\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Creates/deploys the RBAC implementation to be used in a proxy\n\t *\n\t * @dev Note:\n\t *      the implementation is already initialized and\n\t *      `_postConstruct` is not executable on the implementation\n\t *      `_postConstruct` is still available in the context of a proxy\n\t *      and should be executed on the proxy deployment (in the same tx)\n\t */\n\tconstructor() initializer {}\n\n\t/**\n\t * @dev Contract initializer, sets the contract owner to have full privileges\n\t *\n\t * @dev Can be executed only once, reverts when executed second time\n\t *\n\t * @dev IMPORTANT:\n\t *      this function SHOULD be executed during proxy deployment (in the same transaction)\n\t *\n\t * @param _owner smart contract owner having full privileges, can be zero\n\t * @param _features initial features mask of the contract, can be zero\n\t */\n\tfunction _postConstruct(address _owner, uint256 _features) internal virtual onlyInitializing {\n\t\t// grant owner full privileges\n\t\t__setRole(_owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t\t// update initial features bitmask\n\t\t__setRole(address(this), _features, _features);\n\t}\n\n\t/**\n\t * @dev Highest version that has been initialized.\n\t *      Non-zero value means contract was already initialized.\n\t * @dev see {Initializable}, {reinitializer}.\n\t *\n\t * @return highest version that has been initialized\n\t */\n\tfunction getInitializedVersion() public view returns(uint64) {\n\t\t// delegate to `_getInitializedVersion`\n\t\treturn _getInitializedVersion();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address mapping of `userRoles`\n\t\treturn getRole(address(this));\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Reads the permissions (role) for a given user from the `userRoles` mapping\n\t *      (privileged addresses with defined roles/permissions)\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Having a simple getter instead of making the mapping public\n\t *      allows enforcing the encapsulation of the mapping and protects from\n\t *      writing to it directly in the inheriting smart contracts\n\t *\n\t * @param operator address of a user to read permissions for,\n\t *      or self address to read global features of the smart contract\n\t */\n\tfunction getRole(address operator) public view returns(uint256) {\n\t\t// read the value from `userRoles` and return\n\t\treturn userRoles[operator];\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\t__setRole(operator, role, _evaluateBy(msg.sender, getRole(operator), role));\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction _evaluateBy(address operator, uint256 target, uint256 desired) internal view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = getRole(operator);\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(getRole(operator), required);\n\t}\n\n\t/**\n\t * @dev Sets the `assignedRole` role to the operator, logs both `requestedRole` and `actualRole`\n\t *\n\t * @dev Unsafe:\n\t *      provides direct write access to `userRoles` mapping without any security checks,\n\t *      doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @param operator address of a user to alter permissions for,\n\t *       or self address to alter global features of the smart contract\n\t * @param requestedRole bitmask representing a set of permissions requested\n\t *      to be enabled/disabled for a user specified, used only to be logged into event\n\t * @param assignedRole bitmask representing a set of permissions to\n\t *      enable/disable for a user specified, used to update the mapping and to be logged into event\n\t */\n\tfunction __setRole(address operator, uint256 requestedRole, uint256 assignedRole) private {\n\t\t// assign the role to the operator\n\t\tuserRoles[operator] = assignedRole;\n\n\t\t// fire an event\n\t\temit RoleUpdated(operator, requestedRole, assignedRole);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) private pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\nimport \"./InitializableAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Role-based Access Control (RBAC) // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice This contract is inherited by other contracts requiring the role-based access control (RBAC)\n *      protection for the restricted access functions\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the RBAC, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is InitializableAccessControl, UUPSUpgradeable {\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967Upgradeable {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/IERC1967Upgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n"
    },
    "contracts/interfaces/EIP2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-2612: permit - 712-signed approvals\n *\n * @notice A function permit extending ERC-20 which allows for approvals to be made via secp256k1 signatures.\n *      This kind of “account abstraction for ERC-20” brings about two main benefits:\n *        - transactions involving ERC-20 operations can be paid using the token itself rather than ETH,\n *        - approve and pull operations can happen in a single transaction instead of two consecutive transactions,\n *        - while adding as little as possible over the existing ERC-20 standard.\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-2612#specification\n */\ninterface EIP2612 {\n\t/**\n\t * @notice EIP712 domain separator of the smart contract. It should be unique to the contract\n\t *      and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712,\n\t *      but is otherwise unconstrained.\n\t */\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n\n\t/**\n\t * @notice Counter of the nonces used for the given address; nonce are used sequentially\n\t *\n\t * @dev To prevent from replay attacks nonce is incremented for each address after a successful `permit` execution\n\t *\n\t * @param owner an address to query number of used nonces for\n\t * @return number of used nonce, nonce number to be used next\n\t */\n\tfunction nonces(address owner) external view returns (uint);\n\n\t/**\n\t * @notice For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s,\n\t *      a call to permit(owner, spender, value, deadline, v, r, s) will set approval[owner][spender] to value,\n\t *      increment nonces[owner] by 1, and emit a corresponding Approval event,\n\t *      if and only if the following conditions are met:\n\t *        - The current blocktime is less than or equal to deadline.\n\t *        - owner is not the zero address.\n\t *        - nonces[owner] (before the state update) is equal to nonce.\n\t *        - r, s and v is a valid secp256k1 signature from owner of the message:\n\t *\n\t * @param owner token owner address, granting an approval to spend its tokens\n\t * @param spender an address approved by the owner (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param value an amount of tokens spender `spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n"
    },
    "contracts/interfaces/EIP3009.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-3009: Transfer With Authorization\n *\n * @notice A contract interface that enables transferring of fungible assets via a signed authorization.\n *      See https://eips.ethereum.org/EIPS/eip-3009\n *      See https://eips.ethereum.org/EIPS/eip-3009#specification\n */\ninterface EIP3009 {\n\t/**\n\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\n\t *\n\t * @param authorizer an address which has used the nonce\n\t * @param nonce the nonce used\n\t */\n\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\n\t *\n\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\n\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\n\t *      implies no smart contract state change made (except the nonce marked as cancelled)\n\t *\n\t * @param authorizer an address which has cancelled the nonce\n\t * @param nonce the nonce cancelled\n\t */\n\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\n\n\t/**\n\t * @notice Returns the state of an authorization, more specifically\n\t *      if the specified nonce was already used by the address specified\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\n\t *      unique to the authorizer's address\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @return true if the nonce is used\n\t */\n\tfunction authorizationState(\n\t\taddress authorizer,\n\t\tbytes32 nonce\n\t) external view returns (bool);\n\n\t/**\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address matches\n\t *      the caller of this function to prevent front-running attacks.\n\t * @dev See https://eips.ethereum.org/EIPS/eip-3009#security-considerations\n\t *\n\t * @param from          Payer's address (Authorizer)\n\t * @param to            Payee's address\n\t * @param value         Amount to be transferred\n\t * @param validAfter    The time after which this is valid (unix time)\n\t * @param validBefore   The time before which this is valid (unix time)\n\t * @param nonce         Unique nonce\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value,\n\t\tuint256 validAfter,\n\t\tuint256 validBefore,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param authorizer    Authorizer's address\n\t * @param nonce         Nonce of the authorization\n\t * @param v             v of the signature\n\t * @param r             r of the signature\n\t * @param s             s of the signature\n\t */\n\tfunction cancelAuthorization(\n\t\taddress authorizer,\n\t\tbytes32 nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n}\n"
    },
    "contracts/interfaces/ERC1363Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC20Spec.sol\";\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC1363 Interface\n *\n * @dev Interface defining a ERC1363 Payable Token contract.\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\n */\ninterface ERC1363 is ERC20, ERC165  {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n\t * 0xb0202a11 ===\n\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n\t */\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n\n\t/**\n\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\n\t * @param from address The address which you want to send tokens from\n\t * @param to address The address which you want to transfer to\n\t * @param value uint256 The amount of tokens to be transferred\n\t * @param data bytes Additional data with no specified format, sent in call to `to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t */\n\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\n\n\t/**\n\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\n\t * and then call `onApprovalReceived` on spender.\n\t * @param spender address The address which will spend the funds\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format, sent in call to `spender`\n\t */\n\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\n}\n\n/**\n * @title ERC1363Receiver Interface\n *\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Receiver {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\n\t * 0x88a7ca5c === bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the receipt of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\n\t *      transfer. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\n\t * @param from address The address which are token transferred from\n\t * @param value uint256 The amount of tokens transferred\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\n}\n\n/**\n * @title ERC1363Spender Interface\n *\n * @dev Interface for any contract that wants to support `approveAndCall`\n *      from ERC1363 token contracts.\n */\ninterface ERC1363Spender {\n\t/*\n\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\n\t * 0x7b04a2d0 === bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t */\n\n\t/**\n\t * @notice Handle the approval of ERC1363 tokens\n\t *\n\t * @dev Any ERC1363 smart contract calls this function on the recipient\n\t *      after an `approve`. This function MAY throw to revert and reject the\n\t *      approval. Return of other than the magic value MUST result in the\n\t *      transaction being reverted.\n\t *      Note: the token contract address is always the message sender.\n\t *\n\t * @param owner address The address which called `approveAndCall` function\n\t * @param value uint256 The amount of tokens to be spent\n\t * @param data bytes Additional data with no specified format\n\t * @return `bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))`\n\t *      unless throwing\n\t */\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n\n/**\n * @title Mintable/burnable ERC20 Extension\n *\n * @notice Adds mint/burn functions to ERC20 interface, these functions\n *      are usually present in ERC20 implementations, but these become\n *      a must for the bridged tokens in L2 since the bridge on L2\n *      needs to have a way to mint tokens deposited from L1 to L2\n *      and to burn tokens to be withdrawn from L2 to L1\n */\ninterface MintableBurnableERC20 is ERC20 {\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction mint(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t * @return success true on success, false otherwise\n\t */\n\tfunction burn(address _from, uint256 _value) external returns (bool success);\n}\n"
    },
    "contracts/lib/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n *\n * @dev Copy of the Zeppelin's library:\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`,\n\t * `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"invalid signature\");\n\n\t\treturn signer;\n\t}\n}\n"
    },
    "contracts/mocks/AdvCompMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/AdvancedERC20.sol\";\n\n// Token extension to simplify Compound-like voting delegation testing\ncontract AdvCompMock is AdvancedERC20 {\n\tconstructor(\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _initialHolder,\n\t\tuint256 _initialSupply,\n\t\tuint256 _features\n\t) AdvancedERC20(\n\t\tmsg.sender,\n\t\t_name,\n\t\t_symbol,\n\t\t_initialHolder,\n\t\t_initialSupply,\n\t\t_features\n\t) {}\n\n\t// replaces 3 transactions in CompTest to be put into single block with a single transaction\n\tfunction __delegate_transfer_transfer(address a1, address a2, uint256 val) public {\n\t\tdelegate(a1);      // transaction 1\n\t\ttransfer(a2, val); // transaction 2\n\t\ttransfer(a2, val); // transaction 3\n\t}\n\n\t// taken from CompHarness.sol, used in CompScenarioTest\n\tfunction generateCheckpoints(uint count, uint offset) external {\n\t\tfor (uint i = 1 + offset; i <= count + offset; i++) {\n\t\t\tvotingPowerHistory[msg.sender].push(KV(uint64(i), uint192(i)));\n\t\t}\n\t}\n}\n"
    },
    "contracts/mocks/ERC1363Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\n\n/// @dev Mock for ERC1363Receiver/ERC1363Spender interfaces\ncontract ERC1363Mock is ERC1363Receiver, ERC1363Spender {\n\t// an event to be fired in `onTransferReceived`\n\tevent OnTransferReceived(address indexed operator, address indexed from, uint256 value, bytes data);\n\t// an event to be fired in `onApprovalReceived`\n\tevent OnApprovalReceived(address indexed owner, uint256 value, bytes data);\n\n\t/// @inheritdoc ERC1363Receiver\n\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) public override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnTransferReceived(operator, from, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Receiver(this).onTransferReceived.selector;\n\t}\n\n\t/// @inheritdoc ERC1363Spender\n\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external override returns (bytes4) {\n\t\t// emit an event\n\t\temit OnApprovalReceived(owner, value, data);\n\n\t\t// always return \"success\"\n\t\treturn ERC1363Spender(this).onApprovalReceived.selector;\n\t}\n}\n\n// mock class using IERC1363Receiver\ncontract ERC1363ReceiverMock is ERC1363Receiver {\n\tbytes4 private immutable _retval;\n\tbool private immutable _reverts;\n\n\tevent Received(\n\t\taddress operator,\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onTransferReceived(address operator, address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363ReceiverMock: throwing\");\n\t\temit Received(operator, sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n\n// mock class using IERC1363Spender\ncontract ERC1363SpenderMock is ERC1363Spender {\n\tbytes4 private immutable _retval;\n\tbool private immutable _reverts;\n\n\tevent Approved(\n\t\taddress sender,\n\t\tuint256 amount,\n\t\tbytes data,\n\t\tuint256 gas\n\t);\n\n\tconstructor(bytes4 retval, bool reverts) {\n\t\t_retval = retval;\n\t\t_reverts = reverts;\n\t}\n\n\tfunction onApprovalReceived(address sender, uint256 amount, bytes memory data) public override returns (bytes4) {\n\t\trequire(!_reverts, \"ERC1363SpenderMock: throwing\");\n\t\temit Approved(sender, amount, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/mocks/ERC20InterfaceIdMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n// A mock to support erc20_interface_id.js checking ERC20 interfaceId correctness\ncontract ERC20InterfaceIdMock {\n\t// ERC20 interfaceId\n\tfunction interfaceId() public pure returns(bytes4) {\n\t\treturn type(ERC20).interfaceId;\n\t}\n\n\t// Zeppelin ERC20 interfaceId\n\tfunction zeppelinId() public pure returns(bytes4) {\n\t\treturn type(IERC20).interfaceId;\n\t}\n}\n"
    },
    "contracts/protocol/GenericFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/UpgradeableAccessControl.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\n/**\n * @title Generic Factory, a.k.a Generic Smart Contract Deployer\n *\n * @notice A helper stand-alone contract allowing to \"clone\" anything\n *\n * @dev The deployment is done via EIP-1167 Minimal Proxy Contract\n *      See https://eips.ethereum.org/EIPS/eip-1167\n *\n * @author Basil Gorin\n */\ncontract GenericFactoryV1 is UpgradeableAccessControl {\n\t/**\n\t * @dev Fired in clone()\n\t *\n\t * @param by an address which made the deployment (clone), msg.sender\n\t * @param proxyAddress deployed EIP-1167 clone (proxy) address,\n\t *      this is the main `clone()` function output\n\t * @param implAddress impl address used for cloning\n\t * @param data optional data bytes passed to the proxy for initialization;\n\t *      can be empty, in which case this means proxy wasn't initialized\n\t * @param returnData when data field is used, contains the response from low-level\n\t *      proxy initialization call; can be empty\n\t */\n\tevent ProxyDeployed(\n\t\taddress indexed by,\n\t\taddress proxyAddress,\n\t\taddress indexed implAddress,\n\t\tbytes data,\n\t\tbytes returnData\n\t);\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t */\n\tfunction postConstruct() public initializer {\n\t\t// initialize the RBAC module\n\t\t_postConstruct(msg.sender, 0);\n\t}\n\n\t/**\n\t * @notice Clones the specified contract and optionally initializes it immediately\n\t *\n\t * @dev Technically this deploys a tiny EIP 1167 proxy pointing to the impl address specified\n\t *      and optionally initializes it immediately, making the deployment safe and ready for use\n\t *\n\t * @dev Throws on proxy initialization failure\n\t *\n\t * @param _implAddress contract implementation address to clone\n\t * @param _data optional bytes data to execute the low-level call on cloned instance for initialization\n\t */\n\tfunction clone(address _implAddress, bytes calldata _data) public returns(address proxyAddress, bytes memory returnData) {\n\t\t// \"clone\" the impl (deploy a proxy)\n\t\tproxyAddress = Clones.clone(_implAddress);\n\n\t\t// if initialization data is specified\n\t\tif(_data.length > 0) {\n\t\t\t// allocate the variable to store low-level call status\n\t\t\tbool success;\n\t\t\t// initialize the proxy by invoking the low-level call\n\t\t\t(success, returnData) = proxyAddress.call(_data);\n\t\t\t// we require the call to be successful\n\t\t\trequire(success, \"proxy initialization failed\");\n\t\t}\n\n\t\t// emit an event\n\t\temit ProxyDeployed(msg.sender, proxyAddress, _implAddress, _data, returnData);\n\n\t\t// explicitly return the results\n\t\treturn (proxyAddress, returnData);\n\t}\n}\n"
    },
    "contracts/token/AdvancedERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC1363Spec.sol\";\nimport \"../interfaces/EIP2612.sol\";\nimport \"../interfaces/EIP3009.sol\";\nimport \"../lib/ECDSA.sol\";\n\nimport \"@lazy-sol/access-control-upgradeable/contracts/InitializableAccessControl.sol\";\n\n/**\n * @title Advanced ERC20\n *\n * @notice Feature rich lightweight ERC20 implementation which is not built on top of OpenZeppelin ERC20 implementation.\n *      It uses some other OpenZeppelin code:\n *         - low level functions to work with ECDSA signatures (recover)\n *         - low level functions to work contract addresses (isContract)\n *         - OZ UUPS proxy and smart contracts upgradeability code\n *\n * @notice Token Summary:\n *      - Symbol: configurable (set on deployment)\n *      - Name: configurable (set on deployment)\n *      - Decimals: 18\n *      - Initial/maximum total supply: configurable (set on deployment)\n *      - Initial supply holder (initial holder) address: configurable (set on deployment)\n *      - Mintability: configurable (initially enabled, but possible to revoke forever)\n *      - Burnability: configurable (initially enabled, but possible to revoke forever)\n *      - DAO Support: supports voting delegation\n *\n * @notice Features Summary:\n *      - Supports atomic allowance modification, resolves well-known ERC20 issue with approve (arXiv:1907.00903)\n *      - Voting delegation and delegation on behalf via EIP-712 (like in Compound CMP token) - gives the token\n *        powerful governance capabilities by allowing holders to form voting groups by electing delegates\n *      - Unlimited approval feature (like in 0x ZRX token) - saves gas for transfers on behalf\n *        by eliminating the need to update “unlimited” allowance value\n *      - ERC-1363 Payable Token - ERC721-like callback execution mechanism for transfers,\n *        transfers on behalf and approvals; allows creation of smart contracts capable of executing callbacks\n *        in response to transfer or approval in a single transaction\n *      - EIP-2612: permit - 712-signed approvals - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *      - EIP-3009: Transfer With Authorization - improves user experience by allowing to use a token\n *        without having an ETH to pay gas fees\n *\n * @notice This smart contract can be used as is, but also can be inherited and used as a template.\n *\n * @dev Even though smart contract has mint() function which is used to mint initial token supply,\n *      the function is disabled forever after smart contract deployment by revoking `TOKEN_CREATOR`\n *      permission from the deployer account\n *\n * @dev Token balances and total supply are effectively 192 bits long, meaning that maximum\n *      possible total supply smart contract is able to track is 2^192 (close to 10^40 tokens)\n *\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\n *\n * @dev Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) - resolved\n *      Related events and functions are marked with \"arXiv:1907.00903\" tag:\n *        - event Transfer(address indexed _by, address indexed _from, address indexed _to, uint256 _value)\n *        - event Approve(address indexed _owner, address indexed _spender, uint256 _oldValue, uint256 _value)\n *        - function increaseAllowance(address _spender, uint256 _value) public returns (bool)\n *        - function decreaseAllowance(address _spender, uint256 _value) public returns (bool)\n *      See: https://arxiv.org/abs/1907.00903v1\n *           https://ieeexplore.ieee.org/document/8802438\n *      See: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n *\n * @dev Reviewed\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\n *\n * @dev ERC20: contract has passed\n *      - OpenZeppelin ERC20 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\n *      - Ref ERC1363 tests\n *        https://github.com/vittominacori/erc1363-payable-token/blob/master/test/token/ERC1363/ERC1363.behaviour.js\n *      - OpenZeppelin EIP2612 tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/draft-ERC20Permit.test.js\n *      - Coinbase EIP3009 tests\n *        https://github.com/CoinbaseStablecoin/eip-3009/blob/master/test/EIP3009.test.ts\n *      - Compound voting delegation tests\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Governance/CompTest.js\n *        https://github.com/compound-finance/compound-protocol/blob/master/tests/Utils/EIP712.js\n *      - OpenZeppelin voting delegation tests\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/extensions/ERC20Votes.test.js\n *      See adopted copies of all the tests in the project test folder\n *\n * @dev Compound-like voting delegation functions', public getters', and events' names\n *      were changed for better code readability (Advanced ERC20 Name <- Comp/Zeppelin name):\n *      - votingDelegates           <- delegates\n *      - votingPowerHistory        <- checkpoints\n *      - votingPowerHistoryLength  <- numCheckpoints\n *      - totalSupplyHistory        <- _totalSupplyCheckpoints (private)\n *      - usedNonces                <- nonces (note: nonces are random instead of sequential)\n *      - DelegateChanged (unchanged)\n *      - VotingPowerChanged        <- DelegateVotesChanged\n *      - votingPowerOf             <- getCurrentVotes\n *      - votingPowerAt             <- getPriorVotes\n *      - totalSupplyAt             <- getPriorTotalSupply\n *      - delegate (unchanged)\n *      - delegateWithAuthorization <- delegateBySig\n * @dev Compound-like voting delegation improved to allow the use of random nonces like in EIP-3009,\n *      instead of sequential; same `usedNonces` EIP-3009 mapping is used to track nonces\n *\n * @dev Reference implementations \"used\":\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - Unlimited allowance: https://github.com/0xProject/protocol\n *      - Voting delegation:   https://github.com/compound-finance/compound-protocol\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\n *                             https://github.com/CoinbaseStablecoin/eip-3009\n *      - Meta transactions:   https://github.com/0xProject/protocol\n *\n * @dev The code is based on Artificial Liquid Intelligence Token (ALI) developed by Alethea team\n * @dev Includes resolutions for ALI ERC20 Audit by Miguel Palhas, https://hackmd.io/@naps62/alierc20-audit\n *\n * @author Basil Gorin\n */\ncontract AdvancedERC20 is ERC1363, MintableBurnableERC20, EIP2612, EIP3009, InitializableAccessControl {\n\t/**\n\t * @notice Name of the token\n\t *\n\t * @notice ERC20 name of the token (long name)\n\t *\n\t * @dev ERC20 `function name() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter name() is created when compiled,\n\t *      it returns the name of the token.\n\t */\n\tstring public name;\n\n\t/**\n\t * @notice Symbol of the token\n\t *\n\t * @notice ERC20 symbol of that token (short name)\n\t *\n\t * @dev ERC20 `function symbol() public view returns (string)`\n\t *\n\t * @dev Field is declared public: getter symbol() is created when compiled,\n\t *      it returns the symbol of the token\n\t */\n\tstring public symbol;\n\n\t/**\n\t * @notice Decimals of the token: 18\n\t *\n\t * @dev ERC20 `function decimals() public view returns (uint8)`\n\t *\n\t * @dev Field is declared public: getter decimals() is created when compiled,\n\t *      it returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\n\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\n\t */\n\tuint8 public constant decimals = 18;\n\n\t/**\n\t * @notice Total supply of the token: initially 10,000,000,000,\n\t *      with the potential to decline over time as some tokens may get burnt but not minted\n\t *\n\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\n\t *\n\t * @dev Field is declared public: getter totalSupply() is created when compiled,\n\t *      it returns the amount of tokens in existence.\n\t */\n\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\n\n\t/**\n\t * @dev A record of all the token balances\n\t * @dev This mapping keeps record of all token owners:\n\t *      owner => balance\n\t */\n\tmapping(address => uint256) private tokenBalances;\n\n\t/**\n\t * @notice A record of each account's voting delegate\n\t *\n\t * @dev Auxiliary data structure used to sum up an account's voting power\n\t *\n\t * @dev This mapping keeps record of all voting power delegations:\n\t *      voting delegator (token owner) => voting delegate\n\t */\n\tmapping(address => address) public votingDelegates;\n\n\t/**\n\t * @notice Auxiliary structure to store key-value pair, used to store:\n\t *      - voting power record (key: block.timestamp, value: voting power)\n\t *      - total supply record (key: block.timestamp, value: total supply)\n\t * @notice A voting power record binds voting power of a delegate to a particular\n\t *      block when the voting power delegation change happened\n\t *         k: block.number when delegation has changed; starting from\n\t *            that block voting power value is in effect\n\t *         v: cumulative voting power a delegate has obtained starting\n\t *            from the block stored in blockNumber\n\t * @notice Total supply record binds total token supply to a particular\n\t *      block when total supply change happened (due to mint/burn operations)\n\t */\n\tstruct KV {\n\t\t/*\n\t\t * @dev key, a block number\n\t\t */\n\t\tuint64 k;\n\n\t\t/*\n\t\t * @dev value, token balance or voting power\n\t\t */\n\t\tuint192 v;\n\t}\n\n\t/**\n\t * @notice A record of each account's voting power historical data\n\t *\n\t * @dev Primarily data structure to store voting power for each account.\n\t *      Voting power sums up from the account's token balance and delegated\n\t *      balances.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing voting\n\t *      power (number of votes) and block number when the checkpoint is saved\n\t *\n\t * @dev Maps voting delegate => voting power record\n\t */\n\tmapping(address => KV[]) public votingPowerHistory;\n\n\t/**\n\t * @notice A record of total token supply historical data\n\t *\n\t * @dev Primarily data structure to store total token supply.\n\t *\n\t * @dev Stores current value and entire history of its changes.\n\t *      The changes are stored as an array of checkpoints (key-value pairs).\n\t *      Checkpoint is an auxiliary data structure containing total\n\t *      token supply and block number when the checkpoint is saved\n\t */\n\tKV[] public totalSupplyHistory;\n\n\t/**\n\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\n\t *\n\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\n\t *\n\t * @dev Maps delegate address => delegate nonce\n\t */\n\tmapping(address => uint256) public override nonces;\n\n\t/**\n\t * @dev A record of used nonces for EIP-3009 transactions\n\t *\n\t * @dev A record of used nonces for signing/validating signatures\n\t *      in `delegateWithAuthorization` for every delegate\n\t *\n\t * @dev Maps authorizer address => nonce => true/false (used unused)\n\t */\n\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\n\n\t/**\n\t * @notice A record of all the allowances to spend tokens on behalf\n\t * @dev Maps token owner address to an address approved to spend\n\t *      some tokens on behalf, maps approved address to that amount\n\t * @dev owner => spender => value\n\t */\n\tmapping(address => mapping(address => uint256)) private transferAllowances;\n\n\t/**\n\t * @notice Enables ERC20 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transfer()` function to succeed\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC20 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed\n\t * @dev Token owner must call `approve()` first to authorize\n\t *      the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\n\t *      checks if the receiver smart contract supports ERC20 tokens\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\n\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\n\t *      check if the receiver smart contract supports ERC20 tokens,\n\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\n\t */\n\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Enables delegators to elect delegates\n\t * @dev Feature FEATURE_DELEGATIONS must be enabled in order for\n\t *      `delegate()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS = 0x0000_0020;\n\n\t/**\n\t * @notice Enables delegators to elect delegates on behalf\n\t *      (via an EIP712 signature)\n\t * @dev Feature FEATURE_DELEGATIONS_ON_BEHALF must be enabled in order for\n\t *      `delegateWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_DELEGATIONS_ON_BEHALF = 0x0000_0040;\n\n\t/**\n\t * @notice Enables ERC-1363 transfers with callback\n\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\n\t *      ERC-1363 `transferFromAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0080;\n\n\t/**\n\t * @notice Enables ERC-1363 approvals with callback\n\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\n\t *      ERC-1363 `approveAndCall` functions to succeed\n\t */\n\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0100;\n\n\t/**\n\t * @notice Enables approvals on behalf (EIP2612 permits\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\n\t *      `permit()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0200;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\n\t *      `transferWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0400;\n\n\t/**\n\t * @notice Enables meta transfers on behalf (EIP3009 transfers\n\t *      via an EIP712 signature)\n\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\n\t *      `receiveWithAuthorization()` function to succeed\n\t */\n\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0800;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\n\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\n\t */\n\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\n\n\t/**\n\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\n\t *      which may be useful to simplify tokens transfers into \"legacy\" smart contracts\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\n\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\n\t *      via `transfer` and `transferFrom` functions in the same way they\n\t *      would via `unsafeTransferFrom` function\n\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\n\t *      doesn't affect the transfer behaviour since\n\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\n\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\n\t */\n\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\n\n\t/**\n\t * @notice EIP-712 contract's domain typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t *\n\t * @dev Note: we do not include version into the domain typehash/separator,\n\t *      it is implied version is concatenated to the name field, like \"AdvancedERC20v1\"\n\t */\n\t// keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\")\n\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\n\n\t/**\n\t * @notice EIP-712 contract domain separator,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t *      note: we specify contract version in its name\n\t */\n\tfunction DOMAIN_SEPARATOR() public view override returns(bytes32) {\n\t\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\n\t\t// note: we specify contract version in its name\n\t\treturn keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\"AdvancedERC20v1\")), block.chainid, address(this)));\n\t}\n\n\t/**\n\t * @notice EIP-712 delegation struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Delegation(address delegate,uint256 nonce,uint256 expiry)\")\n\tbytes32 public constant DELEGATION_TYPEHASH = 0xff41620983935eb4d4a3c7384a066ca8c1d10cef9a5eca9eb97ca735cd14a755;\n\n\t/**\n\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\n\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n\t/**\n\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\n\n\t/**\n\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\")\n\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\n\n\t/**\n\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\n\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\n\t */\n\t// keccak256(\"CancelAuthorization(address authorizer,bytes32 nonce)\")\n\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\n\n\t/**\n\t * @dev Fired in mint() function\n\t *\n\t * @param by an address which minted some tokens (transaction sender)\n\t * @param to an address the tokens were minted to\n\t * @param value an amount of tokens minted\n\t */\n\tevent Minted(address indexed by, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in burn() function\n\t *\n\t * @param by an address which burned some tokens (transaction sender)\n\t * @param from an address the tokens were burnt from\n\t * @param value an amount of tokens burnt\n\t */\n\tevent Burnt(address indexed by, address indexed from, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\n\t *\n\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\n\t *\n\t * @param by an address which performed the transfer\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Similar to ERC20 Approve event, but also logs old approval value\n\t *\n\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\n\t *      may get fired in transfer functions\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param oldValue previously granted amount of tokens to transfer on behalf\n\t * @param value new granted amount of tokens to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingDelegates` mapping has changed,\n\t *      i.e. a delegator address has changed its delegate address\n\t *\n\t * @param source delegator address, a token owner, effectively transaction sender (`by`)\n\t * @param from old delegate, an address which delegate right is revoked\n\t * @param to new delegate, an address which received the voting power\n\t */\n\tevent DelegateChanged(address indexed source, address indexed from, address indexed to);\n\n\t/**\n\t * @dev Notifies that a key-value pair in `votingPowerHistory` mapping has changed,\n\t *      i.e. a delegate's voting power has changed.\n\t *\n\t * @param by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param target delegate whose voting power has changed\n\t * @param fromVal previous number of votes delegate had\n\t * @param toVal new number of votes delegate has\n\t */\n\tevent VotingPowerChanged(address indexed by, address indexed target, uint256 fromVal, uint256 toVal);\n\n\t/**\n\t * @dev Deploys the token smart contract,\n\t *      assigns initial token supply to the address specified\n\t *\n\t * @param _contractOwner smart contract owner (has minting/burning and all other permissions)\n\t * @param _name token name to set\n\t * @param _symbol token symbol to set\n\t * @param _initialHolder owner of the initial token supply\n\t * @param _initialSupply initial token supply\n\t * @param _initialFeatures RBAC features enabled initially\n\t */\n\tconstructor(\n\t\taddress _contractOwner,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _initialHolder,\n\t\tuint256 _initialSupply,\n\t\tuint256 _initialFeatures\n\t) {\n\t\t// delegate to the same `postConstruct` function which would be used\n\t\t// by all the proxies to be deployed and to be pointing to this impl\n\t\tpostConstruct(_contractOwner, _name, _symbol, _initialHolder, _initialSupply, _initialFeatures);\n\t}\n\n\t/**\n\t * @dev \"Constructor replacement\" for a smart contract with a delayed initialization (post-deployment initialization)\n\t *\n\t * @param _contractOwner smart contract owner (has minting/burning and all other permissions)\n\t * @param _name token name to set\n\t * @param _symbol token symbol to set\n\t * @param _initialHolder owner of the initial token supply\n\t * @param _initialSupply initial token supply value\n\t * @param _initialFeatures RBAC features enabled initially\n\t */\n\tfunction postConstruct(\n\t\taddress _contractOwner,\n\t\tstring memory _name,\n\t\tstring memory _symbol,\n\t\taddress _initialHolder,\n\t\tuint256 _initialSupply,\n\t\tuint256 _initialFeatures\n\t) public initializer {\n\t\t// verify name and symbol are set\n\t\trequire(bytes(_name).length > 0, \"token name is not set\");\n\t\trequire(bytes(_symbol).length > 0, \"token symbol is not set\");\n\n\t\t// assign token name and symbol\n\t\tname = _name;\n\t\tsymbol = _symbol;\n\n\t\t// verify initial holder address non-zero (is set) if there is an initial supply to mint\n\t\trequire(_initialSupply == 0 || _initialHolder != address(0), \"_initialHolder not set (zero address)\");\n\n\t\t// if there is an initial supply to mint\n\t\tif(_initialSupply != 0) {\n\t\t\t// mint the initial supply\n\t\t\t__mint(_initialHolder, _initialSupply);\n\t\t}\n\n\t\t// if initial contract owner is specified\n\t\tif(_contractOwner != address(0) || _initialFeatures != 0) {\n\t\t\t// initialize the RBAC module\n\t\t\t_postConstruct(_contractOwner, _initialFeatures);\n\t\t}\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn interfaceId == type(ERC165).interfaceId\n\t\t    || interfaceId == type(ERC20).interfaceId\n\t\t    || interfaceId == type(ERC1363).interfaceId\n\t\t    || interfaceId == type(EIP2612).interfaceId\n\t\t    || interfaceId == type(EIP3009).interfaceId;\n\t}\n\n\t// ===== Start: ERC-1363 functions =====\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\n\t\treturn transferFromAndCall(msg.sender, _to, _value, _data);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\n\t\t// delegate to `transferFromAndCall` passing empty data param\n\t\treturn transferFromAndCall(_from, _to, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be a smart contract, implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to`\n\t * @return true unless throwing\n\t */\n\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \"ERC1363 transfers are disabled\");\n\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, false);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return true unless throwing\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\n\t\t// delegate to `approveAndCall` passing empty data\n\t\treturn approveAndCall(_spender, _value, \"\");\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\n\t *\n\t * @inheritdoc ERC1363\n\t *\n\t * @dev Caller must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onApprovalReceived call to `_spender`\n\t * @return true unless throwing\n\t */\n\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\n\t\t// ensure ERC-1363 approvals are enabled\n\t\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \"ERC1363 approvals are disabled\");\n\n\t\t// execute regular ERC20 approve - delegate to `approve`\n\t\tapprove(_spender, _value);\n\n\t\t// after the successful approve - check if receiver supports\n\t\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyApproved(_spender, _value, _data);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _from representing the previous owner of the given token value\n\t * @param _to target address that will receive the tokens\n\t * @param _value the amount mount of tokens to be transferred\n\t * @param _data [optional] data to send along with the call\n\t * @param allowEoa indicates if function should fail if `_to` is an EOA\n\t */\n\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\n\t\t// if recipient `_to` is EOA\n\t\tif(_to.code.length == 0) { // !AddressUtils.isContract(_to)\n\t\t\t// ensure EOA recipient is allowed\n\t\t\trequire(allowEoa, \"EOA recipient\");\n\n\t\t\t// exit if successful\n\t\t\treturn;\n\t\t}\n\n\t\t// otherwise - if `_to` is a contract - execute onTransferReceived\n\t\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\n\n\t\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\n\t\t// bytes4(keccak256(\"onTransferReceived(address,address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \"invalid onTransferReceived response\");\n\t}\n\n\t/**\n\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\n\t *      The call is not executed if the target address is not a contract; in such\n\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\n\t *\n\t * @dev Throws on any error; returns silently on success\n\t *\n\t * @param _spender the address which will spend the funds\n\t * @param _value the amount of tokens to be spent\n\t * @param _data [optional] data to send along with the call\n\t */\n\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\n\t\t// ensure recipient is not EOA\n\t\trequire(_spender.code.length > 0, \"EOA spender\"); // AddressUtils.isContract(_spender)\n\n\t\t// otherwise - if `_to` is a contract - execute onApprovalReceived\n\t\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\n\n\t\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\n\t\t// bytes4(keccak256(\"onApprovalReceived(address,uint256,bytes)\"))\n\t\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \"invalid onApprovalReceived response\");\n\t}\n\t// ===== End: ERC-1363 functions =====\n\n\t// ===== Start: ERC20 functions =====\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\n\t\t// read the balance and return\n\t\treturn tokenBalances[_owner];\n\t}\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\n\t\t// just delegate call to `transferFrom`,\n\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\treturn transferFrom(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\n\t\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\n\t\t// or unsafe transfer\n\t\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\n\t\t// or receiver has `ROLE_ERC20_RECEIVER` permission\n\t\t// or sender has `ROLE_ERC20_SENDER` permission\n\t\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\n\t\t\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\n\t\t\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\n\t\t\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tunsafeTransferFrom(_from, _to, _value);\n\t\t}\n\t\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\n\t\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\n\t\telse {\n\t\t\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\n\t\t\t// `FEATURE_TRANSFERS` is verified inside it\n\t\t\tsafeTransferFrom(_from, _to, _value, \"\");\n\t\t}\n\n\t\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\n\t\t// if we're here - it means operation successful,\n\t\t// just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to` and then executes `onTransferReceived` callback\n\t *      on the receiver if it is a smart contract (not an EOA)\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC1363Receiver interface\n\t * @dev Returns true on success, throws otherwise\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      implementing ERC1363Receiver\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @param _data [optional] additional data with no specified format,\n\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\n\t * @return true unless throwing\n\t */\n\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\n\t\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\n\t\tunsafeTransferFrom(_from, _to, _value);\n\n\t\t// after the successful transfer - check if receiver supports\n\t\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\n\t\t// reverting whole transaction on any error\n\t\t_notifyTransferred(_from, _to, _value, _data, true);\n\n\t\t// function throws on any error, so if we're here - it means operation successful, just return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\n\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\n\t * @dev Designed to be used by developers when the receiver is known\n\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t * @dev Returns silently on success, throws otherwise\n\t *\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\n\t\t// make an internal transferFrom - delegate to `__transferFrom`\n\t\t__transferFrom(msg.sender, _from, _to, _value);\n\t}\n\n\t/**\n\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\n\t *      and `receiveWithAuthorization`\n\t *\n\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\n\t *\n\t * @param _by an address executing the transfer, it can be token owner itself,\n\t *      or an operator previously approved with `approve()`\n\t * @param _from token sender, token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to token receiver, an address to transfer tokens to\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t */\n\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if `_from` is equal to sender, require transfers feature to be enabled\n\t\t// otherwise require transfers on behalf feature to be enabled\n\t\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == _by? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\t// obviously, zero source address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\t// since for zero value transfer transaction succeeds otherwise\n\t\trequire(_from != address(0), \"transfer from the zero address\");\n\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"transfer to the zero address\");\n\n\t\t// according to the Ethereum ERC20 token standard, it is possible to transfer\n\t\t// tokens to oneself using the transfer or transferFrom functions.\n\t\t// In both cases, the transfer will succeed as long as the sender has a sufficient balance of tokens.\n\t\t// require(_from != _to, \"sender and recipient are the same (_from = _to)\");\n\n\t\t// sending tokens to the token smart contract itself is a client mistake\n\t\trequire(_to != address(this), \"invalid recipient (transfer to the token smart contract itself)\");\n\n\t\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\n\t\t// \"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\"\n\t\tif(_value == 0) {\n\t\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t\t// emit an ERC20 transfer event\n\t\t\temit Transfer(_from, _to, _value);\n\n\t\t\t// don't forget to return - we're done\n\t\t\treturn;\n\t\t}\n\n\t\t// no need to make arithmetic overflow check on the _value - by design of mint()\n\n\t\t// in case of transfer on behalf\n\t\tif(_from != _by) {\n\t\t\t// read allowance value - the amount of tokens allowed to transfer - into the stack\n\t\t\tuint256 _allowance = transferAllowances[_from][_by];\n\n\t\t\t// verify sender has an allowance to transfer amount of tokens requested\n\t\t\trequire(_allowance >= _value, \"transfer amount exceeds allowance\");\n\n\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t// update allowance value on the stack\n\t\t\t\t_allowance -= _value;\n\n\t\t\t\t// update the allowance value in storage\n\t\t\t\ttransferAllowances[_from][_by] = _allowance;\n\n\t\t\t\t// emit an improved atomic approve event\n\t\t\t\temit Approval(_from, _by, _allowance + _value, _allowance);\n\n\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\temit Approval(_from, _by, _allowance);\n\t\t\t}\n\t\t}\n\n\t\t// verify sender has enough tokens to transfer on behalf\n\t\trequire(tokenBalances[_from] >= _value, \"transfer amount exceeds balance\");\n\n\t\t// perform the transfer:\n\t\t// decrease token owner (sender) balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// increase `_to` address (receiver) balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// move voting power associated with the tokens transferred\n\t\t__moveVotingPower(_by, votingDelegates[_from], votingDelegates[_to], _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(_by, _from, _to, _value);\n\n\t\t// emit an ERC20 transfer event\n\t\temit Transfer(_from, _to, _value);\n\t}\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\n\t\t// make an internal approve - delegate to `__approve`\n\t\t__approve(msg.sender, _spender, _value);\n\n\t\t// operation successful, return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\n\t *\n\t * @dev Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the `_owner`\n\t *\n\t * @dev `_owner` must not necessarily own any tokens to grant the permission\n\t * @dev Throws if `_spender` is a zero address\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t */\n\tfunction __approve(address _owner, address _spender, uint256 _value) private {\n\t\t// non-zero spender address check - Zeppelin\n\t\t// obviously, zero spender address is a client mistake\n\t\t// it's not part of ERC20 standard but it's reasonable to fail fast\n\t\trequire(_spender != address(0), \"approve to the zero address\");\n\n\t\t// read old approval value to emmit an improved event (arXiv:1907.00903)\n\t\tuint256 _oldValue = transferAllowances[_owner][_spender];\n\n\t\t// perform an operation: write value requested into the storage\n\t\ttransferAllowances[_owner][_spender] = _value;\n\n\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\temit Approval(_owner, _spender, _oldValue, _value);\n\n\t\t// emit an ERC20 approval event\n\t\temit Approval(_owner, _spender, _value);\n\t}\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @inheritdoc ERC20\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\n\t\t// read the value from storage and return\n\t\treturn transferAllowances[_owner][_spender];\n\t}\n\n\t// ===== End: ERC20 functions =====\n\n\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t/**\n\t * @notice Increases the allowance granted to `spender` by the transaction sender\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to increase by\n\t * @return true unless throwing\n\t */\n\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value and arithmetic overflow check on the allowance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(currentVal + _value > currentVal, \"zero value approval increase or arithmetic overflow\");\n\t\t}\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal + _value);\n\t}\n\n\t/**\n\t * @notice Decreases the allowance granted to `spender` by the caller.\n\t *\n\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *\n\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens to decrease by\n\t * @return true unless throwing\n\t */\n\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\n\t\t// read current allowance value\n\t\tuint256 currentVal = transferAllowances[msg.sender][_spender];\n\n\t\t// non-zero _value check on the allowance\n\t\trequire(_value > 0, \"zero value approval decrease\");\n\n\t\t// verify allowance decrease doesn't underflow\n\t\trequire(currentVal >= _value, \"ERC20: decreased allowance below zero\");\n\n\t\t// delegate call to `approve` with the new value\n\t\treturn approve(_spender, currentVal - _value);\n\t}\n\n\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\n\n\t// ===== Start: Minting/burning extension =====\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint192\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction mint(address _to, uint256 _value) public override virtual returns(bool success) {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// delegate call to unsafe `__mint`\n\t\t__mint(_to, _value);\n\n\t\t// always return true\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Unsafe: doesn't verify the executor (msg.sender) permissions,\n\t *      must be kept private at all times\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction __mint(address _to, uint256 _value) private {\n\t\t// non-zero recipient address check\n\t\trequire(_to != address(0), \"zero address\");\n\n\t\t// non-zero _value and arithmetic overflow check on the total supply\n\t\t// this check automatically secures arithmetic overflow on the individual balance\n\t\tunchecked {\n\t\t\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\n\t\t\trequire(totalSupply + _value > totalSupply, \"zero value or arithmetic overflow\");\n\t\t}\n\n\t\t// uint192 overflow check (required by voting delegation)\n\t\trequire(totalSupply + _value <= type(uint192).max, \"total supply overflow (uint192)\");\n\n\t\t// perform mint:\n\t\t// increase total amount of tokens value\n\t\ttotalSupply += _value;\n\n\t\t// increase `_to` address balance\n\t\ttokenBalances[_to] += _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, add, _value);\n\n\t\t// create voting power associated with the tokens minted\n\t\t__moveVotingPower(msg.sender, address(0), votingDelegates[_to], _value);\n\n\t\t// fire a minted event\n\t\temit Minted(msg.sender, _to, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, address(0), _to, _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(address(0), _to, _value);\n\t}\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction burn(address _from, uint256 _value) public override virtual returns(bool success) {\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// in case of burn on behalf\n\t\t\tif(_from != msg.sender) {\n\t\t\t\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\n\t\t\t\tuint256 _allowance = transferAllowances[_from][msg.sender];\n\n\t\t\t\t// verify sender has an allowance to burn amount of tokens requested\n\t\t\t\trequire(_allowance >= _value, \"burn amount exceeds allowance\");\n\n\t\t\t\t// we treat max uint256 allowance value as an \"unlimited\" and\n\t\t\t\t// do not decrease allowance when it is set to \"unlimited\" value\n\t\t\t\tif(_allowance < type(uint256).max) {\n\t\t\t\t\t// update allowance value on the stack\n\t\t\t\t\t_allowance -= _value;\n\n\t\t\t\t\t// update the allowance value in storage\n\t\t\t\t\ttransferAllowances[_from][msg.sender] = _allowance;\n\n\t\t\t\t\t// emit an improved atomic approve event (arXiv:1907.00903)\n\t\t\t\t\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\n\n\t\t\t\t\t// emit an ERC20 approval event to reflect the decrease\n\t\t\t\t\temit Approval(_from, msg.sender, _allowance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\n\t\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\n\t\t// we have left to execute balance checks and burning logic itself\n\n\t\t// non-zero burn value check\n\t\trequire(_value != 0, \"zero value burn\");\n\n\t\t// non-zero source address check - Zeppelin\n\t\trequire(_from != address(0), \"burn from the zero address\");\n\n\t\t// verify `_from` address has enough tokens to destroy\n\t\t// (basically this is a arithmetic overflow check)\n\t\trequire(tokenBalances[_from] >= _value, \"burn amount exceeds balance\");\n\n\t\t// perform burn:\n\t\t// decrease `_from` address balance\n\t\ttokenBalances[_from] -= _value;\n\n\t\t// decrease total amount of tokens value\n\t\ttotalSupply -= _value;\n\n\t\t// update total token supply history\n\t\t__updateHistory(totalSupplyHistory, sub, _value);\n\n\t\t// destroy voting power associated with the tokens burnt\n\t\t__moveVotingPower(msg.sender, votingDelegates[_from], address(0), _value);\n\n\t\t// fire a burnt event\n\t\temit Burnt(msg.sender, _from, _value);\n\n\t\t// emit an improved transfer event (arXiv:1907.00903)\n\t\temit Transfer(msg.sender, _from, address(0), _value);\n\n\t\t// fire ERC20 compliant transfer event\n\t\temit Transfer(_from, address(0), _value);\n\n\t\t// always return true\n\t\treturn true;\n\t}\n\n\t// ===== End: Minting/burning extension =====\n\n\t// ===== Start: EIP-2612 functions =====\n\n\t/**\n\t * @inheritdoc EIP2612\n\t *\n\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\n\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\n\t *\n\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\n\t *      given `_owner` EIP-712 signed approval\n\t *\n\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\n\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\n\t *      if this might become an issue:\n\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\n\t *\n\t * @dev Emits `Approval` event(s) in the same way as `approve` does\n\t *\n\t * @dev Requires:\n\t *     - `_spender` to be non-zero address\n\t *     - `_exp` to be a timestamp in the future\n\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\n\t *        over the EIP712-formatted function arguments.\n\t *     - the signature to use `_owner` current nonce (see `nonces`).\n\t *\n\t * @dev For more information on the signature format, see the\n\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\n\t *\n\t * @param _owner owner of the tokens to set approval on behalf of,\n\t *      an address which signed the EIP-712 message\n\t * @param _spender an address approved by the token owner\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @param _exp signature expiration time (unix timestamp)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\n\t\t// verify permits are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \"EIP2612 permits are disabled\");\n\n\t\t// derive signer of the EIP712 Permit message, and\n\t\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓\n\t\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _owner, \"invalid signature\");\n\t\trequire(block.timestamp < _exp, \"signature expired\");\n\n\t\t// delegate call to `__approve` - execute the logic required\n\t\t__approve(_owner, _spender, _value);\n\t}\n\n\t// ===== End: EIP-2612 functions =====\n\n\t// ===== Start: EIP-3009 functions =====\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Checks if specified nonce was already used\n\t *\n\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\n\t *      unique to the authorizer's address\n\t *\n\t * @dev Alias for usedNonces(authorizer, nonce)\n\t *\n\t * @param _authorizer an address to check nonce for\n\t * @param _nonce a nonce to check\n\t * @return true if the nonce was used, false otherwise\n\t */\n\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\n\t\t// simply return the value from the mapping\n\t\treturn usedNonces[_authorizer][_nonce];\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Execute a transfer with a signed authorization\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction transferWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// ensure EIP-3009 transfers are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \"EIP3009 transfers are disabled\");\n\n\t\t// derive signer of the EIP712 TransferWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Receive a transfer with a signed authorization from the payer\n\t *\n\t * @dev This has an additional check to ensure that the payee's address\n\t *      matches the caller of this function to prevent front-running attacks.\n\t *\n\t * @param _from token sender and transaction authorizer\n\t * @param _to token receiver\n\t * @param _value amount to be transferred\n\t * @param _validAfter signature valid after time (unix timestamp)\n\t * @param _validBefore signature valid before time (unix timestamp)\n\t * @param _nonce unique random nonce\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction receiveWithAuthorization(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _value,\n\t\tuint256 _validAfter,\n\t\tuint256 _validBefore,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// verify EIP3009 receptions are enabled\n\t\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \"EIP3009 receptions are disabled\");\n\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _from, \"invalid signature\");\n\t\trequire(block.timestamp > _validAfter, \"signature not yet valid\");\n\t\trequire(block.timestamp < _validBefore, \"signature expired\");\n\t\trequire(_to == msg.sender, \"access denied\");\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_from, _nonce, false);\n\n\t\t// delegate call to `__transferFrom` - execute the logic required\n\t\t__transferFrom(signer, _from, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc EIP3009\n\t *\n\t * @notice Attempt to cancel an authorization\n\t *\n\t * @param _authorizer transaction authorizer\n\t * @param _nonce unique random nonce to cancel (mark as used)\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction cancelAuthorization(\n\t\taddress _authorizer,\n\t\tbytes32 _nonce,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public override {\n\t\t// derive signer of the EIP712 ReceiveWithAuthorization message\n\t\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(signer == _authorizer, \"invalid signature\");\n\n\t\t// cancel the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(_authorizer, _nonce, true);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\n\t *\n\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\n\t\t// build the EIP-712 hashStruct of the message\n\t\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\n\n\t\t// calculate the EIP-712 digest \"\\x19\\x01\" ‖ domainSeparator ‖ hashStruct(message)\n\t\tbytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\n\n\t\t// recover the address which signed the message with v, r, s\n\t\taddress signer = ECDSA.recover(digest, v, r, s);\n\n\t\t// according to EIP3009 spec, zero address must be rejected when using ecrecover\n\t\t// this check already happened inside `ECDSA.recover`\n\n\t\t// return the signer address derived from the signature\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\n\t *      1. Verifies the nonce was not used before\n\t *      2. Marks the nonce as used\n\t *      3. Emits an event that the nonce was used/cancelled\n\t *\n\t * @dev Set `_cancellation` to false (default) to use nonce,\n\t *      set `_cancellation` to true to cancel nonce\n\t *\n\t * @dev It is expected that the nonce supplied is a randomly\n\t *      generated uint256 generated by the client\n\t *\n\t * @param _authorizer an address to use/cancel nonce for\n\t * @param _nonce random nonce to use\n\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\n\t */\n\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\n\t\t// verify nonce was not used before\n\t\trequire(!usedNonces[_authorizer][_nonce], \"invalid nonce\");\n\n\t\t// update the nonce state to \"used\" for that particular signer to avoid replay attack\n\t\tusedNonces[_authorizer][_nonce] = true;\n\n\t\t// depending on the usage type (use/cancel)\n\t\tif(_cancellation) {\n\t\t\t// emit an event regarding the nonce cancelled\n\t\t\temit AuthorizationCanceled(_authorizer, _nonce);\n\t\t}\n\t\telse {\n\t\t\t// emit an event regarding the nonce used\n\t\t\temit AuthorizationUsed(_authorizer, _nonce);\n\t\t}\n\t}\n\n\t// ===== End: EIP-3009 functions =====\n\n\t// ===== Start: DAO Support (Compound-like voting delegation) =====\n\n\t/**\n\t * @notice Gets current voting power of the account `_of`\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @return current cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators\n\t */\n\tfunction votingPowerOf(address _of) public view returns (uint256) {\n\t\t// get a link to an array of voting power history records for an address specified\n\t\tKV[] storage history = votingPowerHistory[_of];\n\n\t\t// lookup the history and return latest element\n\t\treturn history.length == 0? 0: history[history.length - 1].v;\n\t}\n\n\t/**\n\t * @notice Gets past voting power of the account `_of` at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _of the address of account to get voting power of\n\t * @param _blockNum block number to get the voting power at\n\t * @return past cumulative voting power of the account,\n\t *      sum of token balances of all its voting delegators at block number `_blockNum`\n\t */\n\tfunction votingPowerAt(address _of, uint256 _blockNum) public view returns (uint256) {\n\t\t// make sure block number is in the past (the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\"); // Compound msg not yet determined\n\n\t\t// `votingPowerHistory[_of]` is an array ordered by `blockNumber`, ascending;\n\t\t// apply binary search on `votingPowerHistory[_of]` to find such an entry number `i`, that\n\t\t// `votingPowerHistory[_of][i].k <= _blockNum`, but in the same time\n\t\t// `votingPowerHistory[_of][i + 1].k > _blockNum`\n\t\t// return the result - voting power found at index `i`\n\t\treturn __binaryLookup(votingPowerHistory[_of], _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire voting power history array for the delegate specified\n\t *\n\t * @param _of delegate to query voting power history for\n\t * @return voting power history array for the delegate of interest\n\t */\n\tfunction votingPowerHistoryOf(address _of) public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn votingPowerHistory[_of];\n\t}\n\n\t/**\n\t * @dev Returns length of the voting power history array for the delegate specified;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @param _of delegate to query voting power history length for\n\t * @return voting power history array length for the delegate of interest\n\t */\n\tfunction votingPowerHistoryLength(address _of) public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn votingPowerHistory[_of].length;\n\t}\n\n\t/**\n\t * @notice Gets past total token supply value at some block `_blockNum`\n\t *\n\t * @dev Throws if `_blockNum` is not in the past (not the finalized block)\n\t *\n\t * @param _blockNum block number to get the total token supply at\n\t * @return past total token supply at block number `_blockNum`\n\t */\n\tfunction totalSupplyAt(uint256 _blockNum) public view returns(uint256) {\n\t\t// make sure block number is in the past (the finalized block)\n\t\trequire(_blockNum < block.number, \"block not yet mined\");\n\n\t\t// `totalSupplyHistory` is an array ordered by `k`, ascending;\n\t\t// apply binary search on `totalSupplyHistory` to find such an entry number `i`, that\n\t\t// `totalSupplyHistory[i].k <= _blockNum`, but in the same time\n\t\t// `totalSupplyHistory[i + 1].k > _blockNum`\n\t\t// return the result - value `totalSupplyHistory[i].v` found at index `i`\n\t\treturn __binaryLookup(totalSupplyHistory, _blockNum);\n\t}\n\n\t/**\n\t * @dev Reads an entire total token supply history array\n\t *\n\t * @return total token supply history array, a key-value pair array,\n\t *      where key is a block number and value is total token supply at that block\n\t */\n\tfunction entireSupplyHistory() public view returns(KV[] memory) {\n\t\t// return an entire array as memory\n\t\treturn totalSupplyHistory;\n\t}\n\n\t/**\n\t * @dev Returns length of the total token supply history array;\n\t *      useful since reading an entire array just to get its length is expensive (gas cost)\n\t *\n\t * @return total token supply history array\n\t */\n\tfunction totalSupplyHistoryLength() public view returns(uint256) {\n\t\t// read array length and return\n\t\treturn totalSupplyHistory.length;\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator `msg.sender` to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @param _to address to delegate voting power to\n\t */\n\tfunction delegate(address _to) public {\n\t\t// verify delegations are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS), \"delegations are disabled\");\n\t\t// delegate call to `__delegate`\n\t\t__delegate(msg.sender, _to);\n\t}\n\n\t/**\n\t * @dev Powers the meta transaction for `delegate` - `delegateWithAuthorization`\n\t *\n\t * @dev Auxiliary function to delegate delegator's `_from` voting power to the delegate `_to`\n\t * @dev Writes to `votingDelegates` and `votingPowerHistory` mappings\n\t *\n\t * @param _from delegator who delegates his voting power\n\t * @param _to delegate who receives the voting power\n\t */\n\tfunction __delegate(address _from, address _to) private {\n\t\t// read current delegate to be replaced by a new one\n\t\taddress _fromDelegate = votingDelegates[_from];\n\n\t\t// read current voting power (it is equal to token balance)\n\t\tuint256 _value = tokenBalances[_from];\n\n\t\t// reassign voting delegate to `_to`\n\t\tvotingDelegates[_from] = _to;\n\n\t\t// update voting power for `_fromDelegate` and `_to`\n\t\t__moveVotingPower(_from, _fromDelegate, _to, _value);\n\n\t\t// emit an event\n\t\temit DelegateChanged(_from, _fromDelegate, _to);\n\t}\n\n\t/**\n\t * @notice Delegates voting power of the delegator (represented by its signature) to the delegate `_to`\n\t *\n\t * @dev Accepts zero value address to delegate voting power to, effectively\n\t *      removing the delegate in that case\n\t *\n\t * @dev Compliant with EIP-712: Ethereum typed structured data hashing and signing,\n\t *      see https://eips.ethereum.org/EIPS/eip-712\n\t *\n\t * @param _to address to delegate voting power to\n\t * @param _nonce nonce used to construct the signature, and used to validate it;\n\t *      nonce is increased by one after successful signature validation and vote delegation\n\t * @param _exp signature expiration time\n\t * @param v the recovery byte of the signature\n\t * @param r half of the ECDSA signature pair\n\t * @param s half of the ECDSA signature pair\n\t */\n\tfunction delegateWithAuthorization(address _to, bytes32 _nonce, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\n\t\t// verify delegations on behalf are enabled\n\t\trequire(isFeatureEnabled(FEATURE_DELEGATIONS_ON_BEHALF), \"delegations on behalf are disabled\");\n\n\t\t// derive signer of the EIP712 Delegation message\n\t\taddress signer = __deriveSigner(abi.encode(DELEGATION_TYPEHASH, _to, _nonce, _exp), v, r, s);\n\n\t\t// perform message integrity and security validations\n\t\trequire(block.timestamp < _exp, \"signature expired\"); // Compound msg\n\n\t\t// use the nonce supplied (verify, mark as used, emit event)\n\t\t__useNonce(signer, _nonce, false);\n\n\t\t// delegate call to `__delegate` - execute the logic required\n\t\t__delegate(signer, _to);\n\t}\n\n\t/**\n\t * @dev Auxiliary function to move voting power `_value`\n\t *      from delegate `_from` to the delegate `_to`\n\t *\n\t * @dev Doesn't have any effect if `_from == _to`, or if `_value == 0`\n\t *\n\t * @param _by an address which executed delegate, mint, burn, or transfer operation\n\t *      which had led to delegate voting power change\n\t * @param _from delegate to move voting power from\n\t * @param _to delegate to move voting power to\n\t * @param _value voting power to move from `_from` to `_to`\n\t */\n\tfunction __moveVotingPower(address _by, address _from, address _to, uint256 _value) private {\n\t\t// if there is no move (`_from == _to`) or there is nothing to move (`_value == 0`)\n\t\tif(_from == _to || _value == 0) {\n\t\t\t// return silently with no action\n\t\t\treturn;\n\t\t}\n\n\t\t// if source address is not zero - decrease its voting power\n\t\tif(_from != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_from];\n\n\t\t\t// update source voting power: decrease by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, sub, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _from, _fromVal, _toVal);\n\t\t}\n\n\t\t// if destination address is not zero - increase its voting power\n\t\tif(_to != address(0)) {\n\t\t\t// get a link to an array of voting power history records for an address specified\n\t\t\tKV[] storage _h = votingPowerHistory[_to];\n\n\t\t\t// update destination voting power: increase by `_value`\n\t\t\t(uint256 _fromVal, uint256 _toVal) = __updateHistory(_h, add, _value);\n\n\t\t\t// emit an event\n\t\t\temit VotingPowerChanged(_by, _to, _fromVal, _toVal);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to append key-value pair to an array,\n\t *      sets the key to the current block number and\n\t *      value as derived\n\t *\n\t * @param _h array of key-value pairs to append to\n\t * @param op a function (add/subtract) to apply\n\t * @param _delta the value for a key-value pair to add/subtract\n\t */\n\tfunction __updateHistory(\n\t\tKV[] storage _h,\n\t\tfunction(uint256,uint256) pure returns(uint256) op,\n\t\tuint256 _delta\n\t) private returns(uint256 _fromVal, uint256 _toVal) {\n\t\t// init the old value - value of the last pair of the array\n\t\t_fromVal = _h.length == 0? 0: _h[_h.length - 1].v;\n\t\t// init the new value - result of the operation on the old value\n\t\t_toVal = op(_fromVal, _delta);\n\n\t\t// if there is an existing voting power value stored for current block\n\t\tif(_h.length != 0 && _h[_h.length - 1].k == block.number) {\n\t\t\t// update voting power which is already stored in the current block\n\t\t\t_h[_h.length - 1].v = uint192(_toVal);\n\t\t}\n\t\t// otherwise - if there is no value stored for current block\n\t\telse {\n\t\t\t// add new element into array representing the value for current block\n\t\t\t_h.push(KV(uint64(block.number), uint192(_toVal)));\n\t\t}\n\t}\n\n\t/**\n\t * @dev Auxiliary function to lookup for a value in a sorted by key (ascending)\n\t *      array of key-value pairs\n\t *\n\t * @dev This function finds a key-value pair element in an array with the closest key\n\t *      to the key of interest (not exceeding that key) and returns the value\n\t *      of the key-value pair element found\n\t *\n\t * @dev An array to search in is a KV[] key-value pair array ordered by key `k`,\n\t *      it is sorted in ascending order (`k` increases as array index increases)\n\t *\n\t * @dev Returns zero for an empty array input regardless of the key input\n\t *\n\t * @param _h an array of key-value pair elements to search in\n\t * @param _k key of interest to look the value for\n\t * @return the value of the key-value pair of the key-value pair element with the closest\n\t *      key to the key of interest (not exceeding that key)\n\t */\n\tfunction __binaryLookup(KV[] storage _h, uint256 _k) private view returns(uint256) {\n\t\t// if an array is empty, there is nothing to lookup in\n\t\tif(_h.length == 0) {\n\t\t\t// by documented agreement, fall back to a zero result\n\t\t\treturn 0;\n\t\t}\n\n\t\t// check last key-value pair key:\n\t\t// if the key is smaller than the key of interest\n\t\tif(_h[_h.length - 1].k <= _k) {\n\t\t\t// we're done - return the value from the last element\n\t\t\treturn _h[_h.length - 1].v;\n\t\t}\n\n\t\t// check first voting power history record block number:\n\t\t// if history was never updated before the block of interest\n\t\tif(_h[0].k > _k) {\n\t\t\t// we're done - voting power at the block num of interest was zero\n\t\t\treturn 0;\n\t\t}\n\n\t\t// left bound of the search interval, originally start of the array\n\t\tuint256 i = 0;\n\n\t\t// right bound of the search interval, originally end of the array\n\t\tuint256 j = _h.length - 1;\n\n\t\t// the iteration process narrows down the bounds by\n\t\t// splitting the interval in a half oce per each iteration\n\t\twhile(j > i) {\n\t\t\t// get an index in the middle of the interval [i, j]\n\t\t\tuint256 k = j - (j - i) / 2;\n\n\t\t\t// read an element to compare it with the value of interest\n\t\t\tKV memory kv = _h[k];\n\n\t\t\t// if we've got a strict equal - we're lucky and done\n\t\t\tif(kv.k == _k) {\n\t\t\t\t// just return the result - pair value at index `k`\n\t\t\t\treturn kv.v;\n\t\t\t}\n\t\t\t// if the value of interest is larger - move left bound to the middle\n\t\t\telse if(kv.k < _k) {\n\t\t\t\t// move left bound `i` to the middle position `k`\n\t\t\t\ti = k;\n\t\t\t}\n\t\t\t// otherwise, when the value of interest is smaller - move right bound to the middle\n\t\t\telse {\n\t\t\t\t// move right bound `j` to the middle position `k - 1`:\n\t\t\t\t// element at position `k` is greater and cannot be the result\n\t\t\t\tj = k - 1;\n\t\t\t}\n\t\t}\n\n\t\t// reaching that point means no exact match found\n\t\t// since we're interested in the element which is not larger than the\n\t\t// element of interest, we return the lower bound `i`\n\t\treturn _h[i].v;\n\t}\n\n\t/**\n\t * @dev Adds a + b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @param a addition term 1\n\t * @param b addition term 2\n\t * @return a + b\n\t */\n\tfunction add(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// add `a` to `b` and return\n\t\treturn a + b;\n\t}\n\n\t/**\n\t * @dev Subtracts a - b\n\t *      Function is used as a parameter for other functions\n\t *\n\t * @dev Requires a ≥ b\n\t *\n\t * @param a subtraction term 1\n\t * @param b subtraction term 2, b ≤ a\n\t * @return a - b\n\t */\n\tfunction sub(uint256 a, uint256 b) private pure returns(uint256) {\n\t\t// subtract `b` from `a` and return\n\t\treturn a - b;\n\t}\n\n\t// ===== End: DAO Support (Compound-like voting delegation) =====\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}